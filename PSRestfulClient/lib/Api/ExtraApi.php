<?php
/**
 * ExtraApi
 * PHP version 8.1
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * PSRESTful Service API
 *
 * A proxy service for PromoStandards SOAP to a REST API
 *
 * The version of the OpenAPI document: 0.0.1
 * Contact: devs@psrestful.com
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.17.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\FormDataProcessor;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * ExtraApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class ExtraApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'getBrandsExtraV1BrandsGet' => [
            'application/json',
        ],
        'getBrandsV2' => [
            'application/json',
        ],
        'getCategoriesV2' => [
            'application/json',
        ],
        'getClassificationsExtraV1ProductsExtraIdClassificationsGet' => [
            'application/json',
        ],
        'getCombinedPpcs' => [
            'application/json',
        ],
        'getDecorationsExtraV1SuppliersSupplierCodeDecorationsGet' => [
            'application/json',
        ],
        'getExtraId' => [
            'application/json',
        ],
        'getInventoryV2' => [
            'application/json',
        ],
        'getMetafieldsByTitle' => [
            'application/json',
        ],
        'getPartIdMappingsV2' => [
            'application/json',
        ],
        'getProductExtraV1ProductsProductIdGet' => [
            'application/json',
        ],
        'getProductMetafieldsV2' => [
            'application/json',
        ],
        'getProductPartsExtraV1ProductsProductIdSortedPartsGet' => [
            'application/json',
        ],
        'getProductV2' => [
            'application/json',
        ],
        'getProducts' => [
            'application/json',
        ],
        'getProductsV2' => [
            'application/json',
        ],
        'getSuppliersExtraV1SuppliersGet' => [
            'application/json',
        ],
        'getSuppliersV2' => [
            'application/json',
        ],
        'scrapeExtraV1ScrapeSupplierCodeGet' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation getBrandsExtraV1BrandsGet
     *
     * Get Brands
     *
     * @param  int|null $supplier_id supplier_id (optional)
     * @param  string|null $supplier_code supplier_code (optional)
     * @param  string|null $x_account_id x_account_id (optional)
     * @param  string|null $body body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBrandsExtraV1BrandsGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\BrandResponse|\OpenAPI\Client\Model\HTTPValidationError
     */
    public function getBrandsExtraV1BrandsGet($supplier_id = null, $supplier_code = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getBrandsExtraV1BrandsGet'][0])
    {
        list($response) = $this->getBrandsExtraV1BrandsGetWithHttpInfo($supplier_id, $supplier_code, $x_account_id, $body, $contentType);
        return $response;
    }

    /**
     * Operation getBrandsExtraV1BrandsGetWithHttpInfo
     *
     * Get Brands
     *
     * @param  int|null $supplier_id (optional)
     * @param  string|null $supplier_code (optional)
     * @param  string|null $x_account_id (optional)
     * @param  string|null $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBrandsExtraV1BrandsGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\BrandResponse|\OpenAPI\Client\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBrandsExtraV1BrandsGetWithHttpInfo($supplier_id = null, $supplier_code = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getBrandsExtraV1BrandsGet'][0])
    {
        $request = $this->getBrandsExtraV1BrandsGetRequest($supplier_id, $supplier_code, $x_account_id, $body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\BrandResponse',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\HTTPValidationError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\BrandResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BrandResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getBrandsExtraV1BrandsGetAsync
     *
     * Get Brands
     *
     * @param  int|null $supplier_id (optional)
     * @param  string|null $supplier_code (optional)
     * @param  string|null $x_account_id (optional)
     * @param  string|null $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBrandsExtraV1BrandsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBrandsExtraV1BrandsGetAsync($supplier_id = null, $supplier_code = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getBrandsExtraV1BrandsGet'][0])
    {
        return $this->getBrandsExtraV1BrandsGetAsyncWithHttpInfo($supplier_id, $supplier_code, $x_account_id, $body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBrandsExtraV1BrandsGetAsyncWithHttpInfo
     *
     * Get Brands
     *
     * @param  int|null $supplier_id (optional)
     * @param  string|null $supplier_code (optional)
     * @param  string|null $x_account_id (optional)
     * @param  string|null $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBrandsExtraV1BrandsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBrandsExtraV1BrandsGetAsyncWithHttpInfo($supplier_id = null, $supplier_code = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getBrandsExtraV1BrandsGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\BrandResponse';
        $request = $this->getBrandsExtraV1BrandsGetRequest($supplier_id, $supplier_code, $x_account_id, $body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBrandsExtraV1BrandsGet'
     *
     * @param  int|null $supplier_id (optional)
     * @param  string|null $supplier_code (optional)
     * @param  string|null $x_account_id (optional)
     * @param  string|null $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBrandsExtraV1BrandsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getBrandsExtraV1BrandsGetRequest($supplier_id = null, $supplier_code = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getBrandsExtraV1BrandsGet'][0])
    {






        $resourcePath = '/extra/v1/brands';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $supplier_id,
            'supplier_id', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $supplier_code,
            'supplier_code', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($x_account_id !== null) {
            $headerParams['x-account-id'] = ObjectSerializer::toHeaderValue($x_account_id);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBrandsV2
     *
     * Get Brands
     *
     * @param  int|null $page page (optional, default to 1)
     * @param  int|null $page_size page_size (optional, default to 800)
     * @param  int|null $supplier_id supplier_id (optional)
     * @param  string|null $supplier_code supplier_code (optional)
     * @param  string|null $x_forwarded_for x_forwarded_for (optional)
     * @param  string|null $x_account_id x_account_id (optional)
     * @param  string|null $body body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBrandsV2'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\BrandsResponseV2|\OpenAPI\Client\Model\HTTPValidationError
     */
    public function getBrandsV2($page = 1, $page_size = 800, $supplier_id = null, $supplier_code = null, $x_forwarded_for = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getBrandsV2'][0])
    {
        list($response) = $this->getBrandsV2WithHttpInfo($page, $page_size, $supplier_id, $supplier_code, $x_forwarded_for, $x_account_id, $body, $contentType);
        return $response;
    }

    /**
     * Operation getBrandsV2WithHttpInfo
     *
     * Get Brands
     *
     * @param  int|null $page (optional, default to 1)
     * @param  int|null $page_size (optional, default to 800)
     * @param  int|null $supplier_id (optional)
     * @param  string|null $supplier_code (optional)
     * @param  string|null $x_forwarded_for (optional)
     * @param  string|null $x_account_id (optional)
     * @param  string|null $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBrandsV2'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\BrandsResponseV2|\OpenAPI\Client\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBrandsV2WithHttpInfo($page = 1, $page_size = 800, $supplier_id = null, $supplier_code = null, $x_forwarded_for = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getBrandsV2'][0])
    {
        $request = $this->getBrandsV2Request($page, $page_size, $supplier_id, $supplier_code, $x_forwarded_for, $x_account_id, $body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\BrandsResponseV2',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\HTTPValidationError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\BrandsResponseV2',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BrandsResponseV2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getBrandsV2Async
     *
     * Get Brands
     *
     * @param  int|null $page (optional, default to 1)
     * @param  int|null $page_size (optional, default to 800)
     * @param  int|null $supplier_id (optional)
     * @param  string|null $supplier_code (optional)
     * @param  string|null $x_forwarded_for (optional)
     * @param  string|null $x_account_id (optional)
     * @param  string|null $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBrandsV2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBrandsV2Async($page = 1, $page_size = 800, $supplier_id = null, $supplier_code = null, $x_forwarded_for = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getBrandsV2'][0])
    {
        return $this->getBrandsV2AsyncWithHttpInfo($page, $page_size, $supplier_id, $supplier_code, $x_forwarded_for, $x_account_id, $body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBrandsV2AsyncWithHttpInfo
     *
     * Get Brands
     *
     * @param  int|null $page (optional, default to 1)
     * @param  int|null $page_size (optional, default to 800)
     * @param  int|null $supplier_id (optional)
     * @param  string|null $supplier_code (optional)
     * @param  string|null $x_forwarded_for (optional)
     * @param  string|null $x_account_id (optional)
     * @param  string|null $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBrandsV2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBrandsV2AsyncWithHttpInfo($page = 1, $page_size = 800, $supplier_id = null, $supplier_code = null, $x_forwarded_for = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getBrandsV2'][0])
    {
        $returnType = '\OpenAPI\Client\Model\BrandsResponseV2';
        $request = $this->getBrandsV2Request($page, $page_size, $supplier_id, $supplier_code, $x_forwarded_for, $x_account_id, $body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBrandsV2'
     *
     * @param  int|null $page (optional, default to 1)
     * @param  int|null $page_size (optional, default to 800)
     * @param  int|null $supplier_id (optional)
     * @param  string|null $supplier_code (optional)
     * @param  string|null $x_forwarded_for (optional)
     * @param  string|null $x_account_id (optional)
     * @param  string|null $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBrandsV2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getBrandsV2Request($page = 1, $page_size = 800, $supplier_id = null, $supplier_code = null, $x_forwarded_for = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getBrandsV2'][0])
    {

        if ($page !== null && $page < 1) {
            throw new \InvalidArgumentException('invalid value for "$page" when calling ExtraApi.getBrandsV2, must be bigger than or equal to 1.');
        }
        
        if ($page_size !== null && $page_size > 900) {
            throw new \InvalidArgumentException('invalid value for "$page_size" when calling ExtraApi.getBrandsV2, must be smaller than or equal to 900.');
        }
        if ($page_size !== null && $page_size < 10) {
            throw new \InvalidArgumentException('invalid value for "$page_size" when calling ExtraApi.getBrandsV2, must be bigger than or equal to 10.');
        }
        






        $resourcePath = '/extra/v2/brands';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page_size,
            'page_size', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $supplier_id,
            'supplier_id', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $supplier_code,
            'supplier_code', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($x_forwarded_for !== null) {
            $headerParams['X-Forwarded-For'] = ObjectSerializer::toHeaderValue($x_forwarded_for);
        }
        // header params
        if ($x_account_id !== null) {
            $headerParams['x-account-id'] = ObjectSerializer::toHeaderValue($x_account_id);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCategoriesV2
     *
     * Get Categories
     *
     * @param  int|null $page page (optional, default to 1)
     * @param  int|null $page_size page_size (optional, default to 50)
     * @param  int|null $supplier_id supplier_id (optional)
     * @param  string|null $supplier_code supplier_code (optional)
     * @param  string|null $x_forwarded_for x_forwarded_for (optional)
     * @param  string|null $x_account_id x_account_id (optional)
     * @param  string|null $body body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCategoriesV2'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CategoriesResponseV2|\OpenAPI\Client\Model\HTTPValidationError
     */
    public function getCategoriesV2($page = 1, $page_size = 50, $supplier_id = null, $supplier_code = null, $x_forwarded_for = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getCategoriesV2'][0])
    {
        list($response) = $this->getCategoriesV2WithHttpInfo($page, $page_size, $supplier_id, $supplier_code, $x_forwarded_for, $x_account_id, $body, $contentType);
        return $response;
    }

    /**
     * Operation getCategoriesV2WithHttpInfo
     *
     * Get Categories
     *
     * @param  int|null $page (optional, default to 1)
     * @param  int|null $page_size (optional, default to 50)
     * @param  int|null $supplier_id (optional)
     * @param  string|null $supplier_code (optional)
     * @param  string|null $x_forwarded_for (optional)
     * @param  string|null $x_account_id (optional)
     * @param  string|null $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCategoriesV2'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CategoriesResponseV2|\OpenAPI\Client\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCategoriesV2WithHttpInfo($page = 1, $page_size = 50, $supplier_id = null, $supplier_code = null, $x_forwarded_for = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getCategoriesV2'][0])
    {
        $request = $this->getCategoriesV2Request($page, $page_size, $supplier_id, $supplier_code, $x_forwarded_for, $x_account_id, $body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\CategoriesResponseV2',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\HTTPValidationError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\CategoriesResponseV2',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CategoriesResponseV2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getCategoriesV2Async
     *
     * Get Categories
     *
     * @param  int|null $page (optional, default to 1)
     * @param  int|null $page_size (optional, default to 50)
     * @param  int|null $supplier_id (optional)
     * @param  string|null $supplier_code (optional)
     * @param  string|null $x_forwarded_for (optional)
     * @param  string|null $x_account_id (optional)
     * @param  string|null $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCategoriesV2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCategoriesV2Async($page = 1, $page_size = 50, $supplier_id = null, $supplier_code = null, $x_forwarded_for = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getCategoriesV2'][0])
    {
        return $this->getCategoriesV2AsyncWithHttpInfo($page, $page_size, $supplier_id, $supplier_code, $x_forwarded_for, $x_account_id, $body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCategoriesV2AsyncWithHttpInfo
     *
     * Get Categories
     *
     * @param  int|null $page (optional, default to 1)
     * @param  int|null $page_size (optional, default to 50)
     * @param  int|null $supplier_id (optional)
     * @param  string|null $supplier_code (optional)
     * @param  string|null $x_forwarded_for (optional)
     * @param  string|null $x_account_id (optional)
     * @param  string|null $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCategoriesV2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCategoriesV2AsyncWithHttpInfo($page = 1, $page_size = 50, $supplier_id = null, $supplier_code = null, $x_forwarded_for = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getCategoriesV2'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CategoriesResponseV2';
        $request = $this->getCategoriesV2Request($page, $page_size, $supplier_id, $supplier_code, $x_forwarded_for, $x_account_id, $body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCategoriesV2'
     *
     * @param  int|null $page (optional, default to 1)
     * @param  int|null $page_size (optional, default to 50)
     * @param  int|null $supplier_id (optional)
     * @param  string|null $supplier_code (optional)
     * @param  string|null $x_forwarded_for (optional)
     * @param  string|null $x_account_id (optional)
     * @param  string|null $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCategoriesV2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getCategoriesV2Request($page = 1, $page_size = 50, $supplier_id = null, $supplier_code = null, $x_forwarded_for = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getCategoriesV2'][0])
    {

        if ($page !== null && $page < 1) {
            throw new \InvalidArgumentException('invalid value for "$page" when calling ExtraApi.getCategoriesV2, must be bigger than or equal to 1.');
        }
        
        if ($page_size !== null && $page_size > 200) {
            throw new \InvalidArgumentException('invalid value for "$page_size" when calling ExtraApi.getCategoriesV2, must be smaller than or equal to 200.');
        }
        if ($page_size !== null && $page_size < 1) {
            throw new \InvalidArgumentException('invalid value for "$page_size" when calling ExtraApi.getCategoriesV2, must be bigger than or equal to 1.');
        }
        






        $resourcePath = '/extra/v2/categories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page_size,
            'page_size', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $supplier_id,
            'supplier_id', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $supplier_code,
            'supplier_code', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($x_forwarded_for !== null) {
            $headerParams['X-Forwarded-For'] = ObjectSerializer::toHeaderValue($x_forwarded_for);
        }
        // header params
        if ($x_account_id !== null) {
            $headerParams['x-account-id'] = ObjectSerializer::toHeaderValue($x_account_id);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getClassificationsExtraV1ProductsExtraIdClassificationsGet
     *
     * Get Classifications
     *
     * @param  int $extra_id extra_id (required)
     * @param  string|null $x_account_id x_account_id (optional)
     * @param  string|null $body body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getClassificationsExtraV1ProductsExtraIdClassificationsGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ClassifiersResponse|\OpenAPI\Client\Model\HTTPValidationError
     */
    public function getClassificationsExtraV1ProductsExtraIdClassificationsGet($extra_id, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getClassificationsExtraV1ProductsExtraIdClassificationsGet'][0])
    {
        list($response) = $this->getClassificationsExtraV1ProductsExtraIdClassificationsGetWithHttpInfo($extra_id, $x_account_id, $body, $contentType);
        return $response;
    }

    /**
     * Operation getClassificationsExtraV1ProductsExtraIdClassificationsGetWithHttpInfo
     *
     * Get Classifications
     *
     * @param  int $extra_id (required)
     * @param  string|null $x_account_id (optional)
     * @param  string|null $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getClassificationsExtraV1ProductsExtraIdClassificationsGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ClassifiersResponse|\OpenAPI\Client\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function getClassificationsExtraV1ProductsExtraIdClassificationsGetWithHttpInfo($extra_id, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getClassificationsExtraV1ProductsExtraIdClassificationsGet'][0])
    {
        $request = $this->getClassificationsExtraV1ProductsExtraIdClassificationsGetRequest($extra_id, $x_account_id, $body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ClassifiersResponse',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\HTTPValidationError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\ClassifiersResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ClassifiersResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getClassificationsExtraV1ProductsExtraIdClassificationsGetAsync
     *
     * Get Classifications
     *
     * @param  int $extra_id (required)
     * @param  string|null $x_account_id (optional)
     * @param  string|null $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getClassificationsExtraV1ProductsExtraIdClassificationsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getClassificationsExtraV1ProductsExtraIdClassificationsGetAsync($extra_id, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getClassificationsExtraV1ProductsExtraIdClassificationsGet'][0])
    {
        return $this->getClassificationsExtraV1ProductsExtraIdClassificationsGetAsyncWithHttpInfo($extra_id, $x_account_id, $body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getClassificationsExtraV1ProductsExtraIdClassificationsGetAsyncWithHttpInfo
     *
     * Get Classifications
     *
     * @param  int $extra_id (required)
     * @param  string|null $x_account_id (optional)
     * @param  string|null $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getClassificationsExtraV1ProductsExtraIdClassificationsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getClassificationsExtraV1ProductsExtraIdClassificationsGetAsyncWithHttpInfo($extra_id, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getClassificationsExtraV1ProductsExtraIdClassificationsGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ClassifiersResponse';
        $request = $this->getClassificationsExtraV1ProductsExtraIdClassificationsGetRequest($extra_id, $x_account_id, $body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getClassificationsExtraV1ProductsExtraIdClassificationsGet'
     *
     * @param  int $extra_id (required)
     * @param  string|null $x_account_id (optional)
     * @param  string|null $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getClassificationsExtraV1ProductsExtraIdClassificationsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getClassificationsExtraV1ProductsExtraIdClassificationsGetRequest($extra_id, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getClassificationsExtraV1ProductsExtraIdClassificationsGet'][0])
    {

        // verify the required parameter 'extra_id' is set
        if ($extra_id === null || (is_array($extra_id) && count($extra_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $extra_id when calling getClassificationsExtraV1ProductsExtraIdClassificationsGet'
            );
        }




        $resourcePath = '/extra/v1/products/{extra_id}/classifications';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_account_id !== null) {
            $headerParams['x-account-id'] = ObjectSerializer::toHeaderValue($x_account_id);
        }

        // path params
        if ($extra_id !== null) {
            $resourcePath = str_replace(
                '{' . 'extra_id' . '}',
                ObjectSerializer::toPathValue($extra_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCombinedPpcs
     *
     * Get Combined Ppcs
     *
     * @param  int $product_id product_id (required)
     * @param  string $fob_point_id FOB Point ID (required)
     * @param  string|null $currency Currency for pricing (USD or CAD) (optional, default to 'USD')
     * @param  string|null $x_forwarded_for x_forwarded_for (optional)
     * @param  string|null $x_account_id x_account_id (optional)
     * @param  string|null $body body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCombinedPpcs'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CombinedPPC|\OpenAPI\Client\Model\HTTPValidationError
     */
    public function getCombinedPpcs($product_id, $fob_point_id, $currency = 'USD', $x_forwarded_for = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getCombinedPpcs'][0])
    {
        list($response) = $this->getCombinedPpcsWithHttpInfo($product_id, $fob_point_id, $currency, $x_forwarded_for, $x_account_id, $body, $contentType);
        return $response;
    }

    /**
     * Operation getCombinedPpcsWithHttpInfo
     *
     * Get Combined Ppcs
     *
     * @param  int $product_id (required)
     * @param  string $fob_point_id FOB Point ID (required)
     * @param  string|null $currency Currency for pricing (USD or CAD) (optional, default to 'USD')
     * @param  string|null $x_forwarded_for (optional)
     * @param  string|null $x_account_id (optional)
     * @param  string|null $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCombinedPpcs'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CombinedPPC|\OpenAPI\Client\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCombinedPpcsWithHttpInfo($product_id, $fob_point_id, $currency = 'USD', $x_forwarded_for = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getCombinedPpcs'][0])
    {
        $request = $this->getCombinedPpcsRequest($product_id, $fob_point_id, $currency, $x_forwarded_for, $x_account_id, $body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\CombinedPPC',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\HTTPValidationError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\CombinedPPC',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CombinedPPC',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getCombinedPpcsAsync
     *
     * Get Combined Ppcs
     *
     * @param  int $product_id (required)
     * @param  string $fob_point_id FOB Point ID (required)
     * @param  string|null $currency Currency for pricing (USD or CAD) (optional, default to 'USD')
     * @param  string|null $x_forwarded_for (optional)
     * @param  string|null $x_account_id (optional)
     * @param  string|null $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCombinedPpcs'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCombinedPpcsAsync($product_id, $fob_point_id, $currency = 'USD', $x_forwarded_for = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getCombinedPpcs'][0])
    {
        return $this->getCombinedPpcsAsyncWithHttpInfo($product_id, $fob_point_id, $currency, $x_forwarded_for, $x_account_id, $body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCombinedPpcsAsyncWithHttpInfo
     *
     * Get Combined Ppcs
     *
     * @param  int $product_id (required)
     * @param  string $fob_point_id FOB Point ID (required)
     * @param  string|null $currency Currency for pricing (USD or CAD) (optional, default to 'USD')
     * @param  string|null $x_forwarded_for (optional)
     * @param  string|null $x_account_id (optional)
     * @param  string|null $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCombinedPpcs'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCombinedPpcsAsyncWithHttpInfo($product_id, $fob_point_id, $currency = 'USD', $x_forwarded_for = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getCombinedPpcs'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CombinedPPC';
        $request = $this->getCombinedPpcsRequest($product_id, $fob_point_id, $currency, $x_forwarded_for, $x_account_id, $body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCombinedPpcs'
     *
     * @param  int $product_id (required)
     * @param  string $fob_point_id FOB Point ID (required)
     * @param  string|null $currency Currency for pricing (USD or CAD) (optional, default to 'USD')
     * @param  string|null $x_forwarded_for (optional)
     * @param  string|null $x_account_id (optional)
     * @param  string|null $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCombinedPpcs'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getCombinedPpcsRequest($product_id, $fob_point_id, $currency = 'USD', $x_forwarded_for = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getCombinedPpcs'][0])
    {

        // verify the required parameter 'product_id' is set
        if ($product_id === null || (is_array($product_id) && count($product_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $product_id when calling getCombinedPpcs'
            );
        }

        // verify the required parameter 'fob_point_id' is set
        if ($fob_point_id === null || (is_array($fob_point_id) && count($fob_point_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $fob_point_id when calling getCombinedPpcs'
            );
        }






        $resourcePath = '/extra/v2/products/{product_id}/ppcs';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $currency,
            'currency', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fob_point_id,
            'fob_point_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);

        // header params
        if ($x_forwarded_for !== null) {
            $headerParams['X-Forwarded-For'] = ObjectSerializer::toHeaderValue($x_forwarded_for);
        }
        // header params
        if ($x_account_id !== null) {
            $headerParams['x-account-id'] = ObjectSerializer::toHeaderValue($x_account_id);
        }

        // path params
        if ($product_id !== null) {
            $resourcePath = str_replace(
                '{' . 'product_id' . '}',
                ObjectSerializer::toPathValue($product_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDecorationsExtraV1SuppliersSupplierCodeDecorationsGet
     *
     * Get Decorations
     *
     * @param  string $supplier_code supplier_code (required)
     * @param  string|null $currency currency (optional, default to 'USD')
     * @param  string|null $x_account_id x_account_id (optional)
     * @param  string|null $body body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDecorationsExtraV1SuppliersSupplierCodeDecorationsGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\DecorationsResponse|\OpenAPI\Client\Model\HTTPValidationError
     */
    public function getDecorationsExtraV1SuppliersSupplierCodeDecorationsGet($supplier_code, $currency = 'USD', $x_account_id = null, $body = null, string $contentType = self::contentTypes['getDecorationsExtraV1SuppliersSupplierCodeDecorationsGet'][0])
    {
        list($response) = $this->getDecorationsExtraV1SuppliersSupplierCodeDecorationsGetWithHttpInfo($supplier_code, $currency, $x_account_id, $body, $contentType);
        return $response;
    }

    /**
     * Operation getDecorationsExtraV1SuppliersSupplierCodeDecorationsGetWithHttpInfo
     *
     * Get Decorations
     *
     * @param  string $supplier_code (required)
     * @param  string|null $currency (optional, default to 'USD')
     * @param  string|null $x_account_id (optional)
     * @param  string|null $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDecorationsExtraV1SuppliersSupplierCodeDecorationsGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\DecorationsResponse|\OpenAPI\Client\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDecorationsExtraV1SuppliersSupplierCodeDecorationsGetWithHttpInfo($supplier_code, $currency = 'USD', $x_account_id = null, $body = null, string $contentType = self::contentTypes['getDecorationsExtraV1SuppliersSupplierCodeDecorationsGet'][0])
    {
        $request = $this->getDecorationsExtraV1SuppliersSupplierCodeDecorationsGetRequest($supplier_code, $currency, $x_account_id, $body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\DecorationsResponse',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\HTTPValidationError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\DecorationsResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\DecorationsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getDecorationsExtraV1SuppliersSupplierCodeDecorationsGetAsync
     *
     * Get Decorations
     *
     * @param  string $supplier_code (required)
     * @param  string|null $currency (optional, default to 'USD')
     * @param  string|null $x_account_id (optional)
     * @param  string|null $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDecorationsExtraV1SuppliersSupplierCodeDecorationsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDecorationsExtraV1SuppliersSupplierCodeDecorationsGetAsync($supplier_code, $currency = 'USD', $x_account_id = null, $body = null, string $contentType = self::contentTypes['getDecorationsExtraV1SuppliersSupplierCodeDecorationsGet'][0])
    {
        return $this->getDecorationsExtraV1SuppliersSupplierCodeDecorationsGetAsyncWithHttpInfo($supplier_code, $currency, $x_account_id, $body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDecorationsExtraV1SuppliersSupplierCodeDecorationsGetAsyncWithHttpInfo
     *
     * Get Decorations
     *
     * @param  string $supplier_code (required)
     * @param  string|null $currency (optional, default to 'USD')
     * @param  string|null $x_account_id (optional)
     * @param  string|null $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDecorationsExtraV1SuppliersSupplierCodeDecorationsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDecorationsExtraV1SuppliersSupplierCodeDecorationsGetAsyncWithHttpInfo($supplier_code, $currency = 'USD', $x_account_id = null, $body = null, string $contentType = self::contentTypes['getDecorationsExtraV1SuppliersSupplierCodeDecorationsGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\DecorationsResponse';
        $request = $this->getDecorationsExtraV1SuppliersSupplierCodeDecorationsGetRequest($supplier_code, $currency, $x_account_id, $body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDecorationsExtraV1SuppliersSupplierCodeDecorationsGet'
     *
     * @param  string $supplier_code (required)
     * @param  string|null $currency (optional, default to 'USD')
     * @param  string|null $x_account_id (optional)
     * @param  string|null $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDecorationsExtraV1SuppliersSupplierCodeDecorationsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getDecorationsExtraV1SuppliersSupplierCodeDecorationsGetRequest($supplier_code, $currency = 'USD', $x_account_id = null, $body = null, string $contentType = self::contentTypes['getDecorationsExtraV1SuppliersSupplierCodeDecorationsGet'][0])
    {

        // verify the required parameter 'supplier_code' is set
        if ($supplier_code === null || (is_array($supplier_code) && count($supplier_code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $supplier_code when calling getDecorationsExtraV1SuppliersSupplierCodeDecorationsGet'
            );
        }





        $resourcePath = '/extra/v1/suppliers/{supplier_code}/decorations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $currency,
            'currency', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($x_account_id !== null) {
            $headerParams['x-account-id'] = ObjectSerializer::toHeaderValue($x_account_id);
        }

        // path params
        if ($supplier_code !== null) {
            $resourcePath = str_replace(
                '{' . 'supplier_code' . '}',
                ObjectSerializer::toPathValue($supplier_code),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getExtraId
     *
     * Get Extra Id
     *
     * @param  string $supplier_code Supplier code (required)
     * @param  string $product_id Product ID (required)
     * @param  string|null $x_forwarded_for x_forwarded_for (optional)
     * @param  string|null $x_account_id x_account_id (optional)
     * @param  string|null $body body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getExtraId'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ProductMetafields|\OpenAPI\Client\Model\HTTPValidationError
     */
    public function getExtraId($supplier_code, $product_id, $x_forwarded_for = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getExtraId'][0])
    {
        list($response) = $this->getExtraIdWithHttpInfo($supplier_code, $product_id, $x_forwarded_for, $x_account_id, $body, $contentType);
        return $response;
    }

    /**
     * Operation getExtraIdWithHttpInfo
     *
     * Get Extra Id
     *
     * @param  string $supplier_code Supplier code (required)
     * @param  string $product_id Product ID (required)
     * @param  string|null $x_forwarded_for (optional)
     * @param  string|null $x_account_id (optional)
     * @param  string|null $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getExtraId'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ProductMetafields|\OpenAPI\Client\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function getExtraIdWithHttpInfo($supplier_code, $product_id, $x_forwarded_for = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getExtraId'][0])
    {
        $request = $this->getExtraIdRequest($supplier_code, $product_id, $x_forwarded_for, $x_account_id, $body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ProductMetafields',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\HTTPValidationError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\ProductMetafields',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProductMetafields',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getExtraIdAsync
     *
     * Get Extra Id
     *
     * @param  string $supplier_code Supplier code (required)
     * @param  string $product_id Product ID (required)
     * @param  string|null $x_forwarded_for (optional)
     * @param  string|null $x_account_id (optional)
     * @param  string|null $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getExtraId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getExtraIdAsync($supplier_code, $product_id, $x_forwarded_for = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getExtraId'][0])
    {
        return $this->getExtraIdAsyncWithHttpInfo($supplier_code, $product_id, $x_forwarded_for, $x_account_id, $body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getExtraIdAsyncWithHttpInfo
     *
     * Get Extra Id
     *
     * @param  string $supplier_code Supplier code (required)
     * @param  string $product_id Product ID (required)
     * @param  string|null $x_forwarded_for (optional)
     * @param  string|null $x_account_id (optional)
     * @param  string|null $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getExtraId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getExtraIdAsyncWithHttpInfo($supplier_code, $product_id, $x_forwarded_for = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getExtraId'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ProductMetafields';
        $request = $this->getExtraIdRequest($supplier_code, $product_id, $x_forwarded_for, $x_account_id, $body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getExtraId'
     *
     * @param  string $supplier_code Supplier code (required)
     * @param  string $product_id Product ID (required)
     * @param  string|null $x_forwarded_for (optional)
     * @param  string|null $x_account_id (optional)
     * @param  string|null $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getExtraId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getExtraIdRequest($supplier_code, $product_id, $x_forwarded_for = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getExtraId'][0])
    {

        // verify the required parameter 'supplier_code' is set
        if ($supplier_code === null || (is_array($supplier_code) && count($supplier_code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $supplier_code when calling getExtraId'
            );
        }

        // verify the required parameter 'product_id' is set
        if ($product_id === null || (is_array($product_id) && count($product_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $product_id when calling getExtraId'
            );
        }





        $resourcePath = '/extra/v2/products/get-extra-id/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $supplier_code,
            'supplier_code', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $product_id,
            'product_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);

        // header params
        if ($x_forwarded_for !== null) {
            $headerParams['X-Forwarded-For'] = ObjectSerializer::toHeaderValue($x_forwarded_for);
        }
        // header params
        if ($x_account_id !== null) {
            $headerParams['x-account-id'] = ObjectSerializer::toHeaderValue($x_account_id);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getInventoryV2
     *
     * Get Inventory
     *
     * @param  string $supplier_code supplier_code (required)
     * @param  int|null $page page (optional, default to 1)
     * @param  int|null $page_size page_size (optional, default to 100)
     * @param  string|null $product_id product_id (optional)
     * @param  string|null $part_id part_id (optional)
     * @param  string|null $last_modified__since last_modified__since (optional)
     * @param  string|null $x_forwarded_for x_forwarded_for (optional)
     * @param  string|null $x_account_id x_account_id (optional)
     * @param  string|null $body body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getInventoryV2'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InventoryListResponseV2|\OpenAPI\Client\Model\HTTPValidationError
     */
    public function getInventoryV2($supplier_code, $page = 1, $page_size = 100, $product_id = null, $part_id = null, $last_modified__since = null, $x_forwarded_for = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getInventoryV2'][0])
    {
        list($response) = $this->getInventoryV2WithHttpInfo($supplier_code, $page, $page_size, $product_id, $part_id, $last_modified__since, $x_forwarded_for, $x_account_id, $body, $contentType);
        return $response;
    }

    /**
     * Operation getInventoryV2WithHttpInfo
     *
     * Get Inventory
     *
     * @param  string $supplier_code (required)
     * @param  int|null $page (optional, default to 1)
     * @param  int|null $page_size (optional, default to 100)
     * @param  string|null $product_id (optional)
     * @param  string|null $part_id (optional)
     * @param  string|null $last_modified__since (optional)
     * @param  string|null $x_forwarded_for (optional)
     * @param  string|null $x_account_id (optional)
     * @param  string|null $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getInventoryV2'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InventoryListResponseV2|\OpenAPI\Client\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function getInventoryV2WithHttpInfo($supplier_code, $page = 1, $page_size = 100, $product_id = null, $part_id = null, $last_modified__since = null, $x_forwarded_for = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getInventoryV2'][0])
    {
        $request = $this->getInventoryV2Request($supplier_code, $page, $page_size, $product_id, $part_id, $last_modified__since, $x_forwarded_for, $x_account_id, $body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\InventoryListResponseV2',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\HTTPValidationError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\InventoryListResponseV2',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InventoryListResponseV2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getInventoryV2Async
     *
     * Get Inventory
     *
     * @param  string $supplier_code (required)
     * @param  int|null $page (optional, default to 1)
     * @param  int|null $page_size (optional, default to 100)
     * @param  string|null $product_id (optional)
     * @param  string|null $part_id (optional)
     * @param  string|null $last_modified__since (optional)
     * @param  string|null $x_forwarded_for (optional)
     * @param  string|null $x_account_id (optional)
     * @param  string|null $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getInventoryV2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInventoryV2Async($supplier_code, $page = 1, $page_size = 100, $product_id = null, $part_id = null, $last_modified__since = null, $x_forwarded_for = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getInventoryV2'][0])
    {
        return $this->getInventoryV2AsyncWithHttpInfo($supplier_code, $page, $page_size, $product_id, $part_id, $last_modified__since, $x_forwarded_for, $x_account_id, $body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getInventoryV2AsyncWithHttpInfo
     *
     * Get Inventory
     *
     * @param  string $supplier_code (required)
     * @param  int|null $page (optional, default to 1)
     * @param  int|null $page_size (optional, default to 100)
     * @param  string|null $product_id (optional)
     * @param  string|null $part_id (optional)
     * @param  string|null $last_modified__since (optional)
     * @param  string|null $x_forwarded_for (optional)
     * @param  string|null $x_account_id (optional)
     * @param  string|null $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getInventoryV2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInventoryV2AsyncWithHttpInfo($supplier_code, $page = 1, $page_size = 100, $product_id = null, $part_id = null, $last_modified__since = null, $x_forwarded_for = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getInventoryV2'][0])
    {
        $returnType = '\OpenAPI\Client\Model\InventoryListResponseV2';
        $request = $this->getInventoryV2Request($supplier_code, $page, $page_size, $product_id, $part_id, $last_modified__since, $x_forwarded_for, $x_account_id, $body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getInventoryV2'
     *
     * @param  string $supplier_code (required)
     * @param  int|null $page (optional, default to 1)
     * @param  int|null $page_size (optional, default to 100)
     * @param  string|null $product_id (optional)
     * @param  string|null $part_id (optional)
     * @param  string|null $last_modified__since (optional)
     * @param  string|null $x_forwarded_for (optional)
     * @param  string|null $x_account_id (optional)
     * @param  string|null $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getInventoryV2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getInventoryV2Request($supplier_code, $page = 1, $page_size = 100, $product_id = null, $part_id = null, $last_modified__since = null, $x_forwarded_for = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getInventoryV2'][0])
    {

        // verify the required parameter 'supplier_code' is set
        if ($supplier_code === null || (is_array($supplier_code) && count($supplier_code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $supplier_code when calling getInventoryV2'
            );
        }

        if ($page !== null && $page < 1) {
            throw new \InvalidArgumentException('invalid value for "$page" when calling ExtraApi.getInventoryV2, must be bigger than or equal to 1.');
        }
        
        if ($page_size !== null && $page_size > 500) {
            throw new \InvalidArgumentException('invalid value for "$page_size" when calling ExtraApi.getInventoryV2, must be smaller than or equal to 500.');
        }
        if ($page_size !== null && $page_size < 1) {
            throw new \InvalidArgumentException('invalid value for "$page_size" when calling ExtraApi.getInventoryV2, must be bigger than or equal to 1.');
        }
        







        $resourcePath = '/extra/v2/inventory/{supplier_code}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page_size,
            'page_size', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $product_id,
            'product_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $part_id,
            'part_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_modified__since,
            'last_modified__since', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($x_forwarded_for !== null) {
            $headerParams['X-Forwarded-For'] = ObjectSerializer::toHeaderValue($x_forwarded_for);
        }
        // header params
        if ($x_account_id !== null) {
            $headerParams['x-account-id'] = ObjectSerializer::toHeaderValue($x_account_id);
        }

        // path params
        if ($supplier_code !== null) {
            $resourcePath = str_replace(
                '{' . 'supplier_code' . '}',
                ObjectSerializer::toPathValue($supplier_code),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getMetafieldsByTitle
     *
     * Get Metafields By Title
     *
     * @param  string $supplier_code Supplier code (required)
     * @param  string $title Product title (required)
     * @param  string|null $x_forwarded_for x_forwarded_for (optional)
     * @param  string|null $x_account_id x_account_id (optional)
     * @param  string|null $body body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMetafieldsByTitle'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ProductMetafields|\OpenAPI\Client\Model\HTTPValidationError
     */
    public function getMetafieldsByTitle($supplier_code, $title, $x_forwarded_for = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getMetafieldsByTitle'][0])
    {
        list($response) = $this->getMetafieldsByTitleWithHttpInfo($supplier_code, $title, $x_forwarded_for, $x_account_id, $body, $contentType);
        return $response;
    }

    /**
     * Operation getMetafieldsByTitleWithHttpInfo
     *
     * Get Metafields By Title
     *
     * @param  string $supplier_code Supplier code (required)
     * @param  string $title Product title (required)
     * @param  string|null $x_forwarded_for (optional)
     * @param  string|null $x_account_id (optional)
     * @param  string|null $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMetafieldsByTitle'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ProductMetafields|\OpenAPI\Client\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function getMetafieldsByTitleWithHttpInfo($supplier_code, $title, $x_forwarded_for = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getMetafieldsByTitle'][0])
    {
        $request = $this->getMetafieldsByTitleRequest($supplier_code, $title, $x_forwarded_for, $x_account_id, $body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ProductMetafields',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\HTTPValidationError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\ProductMetafields',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProductMetafields',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getMetafieldsByTitleAsync
     *
     * Get Metafields By Title
     *
     * @param  string $supplier_code Supplier code (required)
     * @param  string $title Product title (required)
     * @param  string|null $x_forwarded_for (optional)
     * @param  string|null $x_account_id (optional)
     * @param  string|null $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMetafieldsByTitle'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMetafieldsByTitleAsync($supplier_code, $title, $x_forwarded_for = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getMetafieldsByTitle'][0])
    {
        return $this->getMetafieldsByTitleAsyncWithHttpInfo($supplier_code, $title, $x_forwarded_for, $x_account_id, $body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getMetafieldsByTitleAsyncWithHttpInfo
     *
     * Get Metafields By Title
     *
     * @param  string $supplier_code Supplier code (required)
     * @param  string $title Product title (required)
     * @param  string|null $x_forwarded_for (optional)
     * @param  string|null $x_account_id (optional)
     * @param  string|null $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMetafieldsByTitle'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMetafieldsByTitleAsyncWithHttpInfo($supplier_code, $title, $x_forwarded_for = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getMetafieldsByTitle'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ProductMetafields';
        $request = $this->getMetafieldsByTitleRequest($supplier_code, $title, $x_forwarded_for, $x_account_id, $body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getMetafieldsByTitle'
     *
     * @param  string $supplier_code Supplier code (required)
     * @param  string $title Product title (required)
     * @param  string|null $x_forwarded_for (optional)
     * @param  string|null $x_account_id (optional)
     * @param  string|null $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMetafieldsByTitle'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getMetafieldsByTitleRequest($supplier_code, $title, $x_forwarded_for = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getMetafieldsByTitle'][0])
    {

        // verify the required parameter 'supplier_code' is set
        if ($supplier_code === null || (is_array($supplier_code) && count($supplier_code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $supplier_code when calling getMetafieldsByTitle'
            );
        }

        // verify the required parameter 'title' is set
        if ($title === null || (is_array($title) && count($title) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $title when calling getMetafieldsByTitle'
            );
        }





        $resourcePath = '/extra/v2/products/get-metafields-by-title/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $supplier_code,
            'supplier_code', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $title,
            'title', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);

        // header params
        if ($x_forwarded_for !== null) {
            $headerParams['X-Forwarded-For'] = ObjectSerializer::toHeaderValue($x_forwarded_for);
        }
        // header params
        if ($x_account_id !== null) {
            $headerParams['x-account-id'] = ObjectSerializer::toHeaderValue($x_account_id);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPartIdMappingsV2
     *
     * Get Part Id Mappings
     *
     * @param  int|null $page page (optional, default to 1)
     * @param  int|null $page_size page_size (optional, default to 50)
     * @param  int|null $supplier supplier (optional)
     * @param  string|null $supplier_code supplier_code (optional)
     * @param  string|null $product_id product_id (optional)
     * @param  string|null $x_forwarded_for x_forwarded_for (optional)
     * @param  string|null $x_account_id x_account_id (optional)
     * @param  string|null $body body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPartIdMappingsV2'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PartIDMappingListResponseV2|\OpenAPI\Client\Model\HTTPValidationError
     */
    public function getPartIdMappingsV2($page = 1, $page_size = 50, $supplier = null, $supplier_code = null, $product_id = null, $x_forwarded_for = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getPartIdMappingsV2'][0])
    {
        list($response) = $this->getPartIdMappingsV2WithHttpInfo($page, $page_size, $supplier, $supplier_code, $product_id, $x_forwarded_for, $x_account_id, $body, $contentType);
        return $response;
    }

    /**
     * Operation getPartIdMappingsV2WithHttpInfo
     *
     * Get Part Id Mappings
     *
     * @param  int|null $page (optional, default to 1)
     * @param  int|null $page_size (optional, default to 50)
     * @param  int|null $supplier (optional)
     * @param  string|null $supplier_code (optional)
     * @param  string|null $product_id (optional)
     * @param  string|null $x_forwarded_for (optional)
     * @param  string|null $x_account_id (optional)
     * @param  string|null $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPartIdMappingsV2'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PartIDMappingListResponseV2|\OpenAPI\Client\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPartIdMappingsV2WithHttpInfo($page = 1, $page_size = 50, $supplier = null, $supplier_code = null, $product_id = null, $x_forwarded_for = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getPartIdMappingsV2'][0])
    {
        $request = $this->getPartIdMappingsV2Request($page, $page_size, $supplier, $supplier_code, $product_id, $x_forwarded_for, $x_account_id, $body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\PartIDMappingListResponseV2',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\HTTPValidationError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\PartIDMappingListResponseV2',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PartIDMappingListResponseV2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getPartIdMappingsV2Async
     *
     * Get Part Id Mappings
     *
     * @param  int|null $page (optional, default to 1)
     * @param  int|null $page_size (optional, default to 50)
     * @param  int|null $supplier (optional)
     * @param  string|null $supplier_code (optional)
     * @param  string|null $product_id (optional)
     * @param  string|null $x_forwarded_for (optional)
     * @param  string|null $x_account_id (optional)
     * @param  string|null $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPartIdMappingsV2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPartIdMappingsV2Async($page = 1, $page_size = 50, $supplier = null, $supplier_code = null, $product_id = null, $x_forwarded_for = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getPartIdMappingsV2'][0])
    {
        return $this->getPartIdMappingsV2AsyncWithHttpInfo($page, $page_size, $supplier, $supplier_code, $product_id, $x_forwarded_for, $x_account_id, $body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPartIdMappingsV2AsyncWithHttpInfo
     *
     * Get Part Id Mappings
     *
     * @param  int|null $page (optional, default to 1)
     * @param  int|null $page_size (optional, default to 50)
     * @param  int|null $supplier (optional)
     * @param  string|null $supplier_code (optional)
     * @param  string|null $product_id (optional)
     * @param  string|null $x_forwarded_for (optional)
     * @param  string|null $x_account_id (optional)
     * @param  string|null $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPartIdMappingsV2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPartIdMappingsV2AsyncWithHttpInfo($page = 1, $page_size = 50, $supplier = null, $supplier_code = null, $product_id = null, $x_forwarded_for = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getPartIdMappingsV2'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PartIDMappingListResponseV2';
        $request = $this->getPartIdMappingsV2Request($page, $page_size, $supplier, $supplier_code, $product_id, $x_forwarded_for, $x_account_id, $body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPartIdMappingsV2'
     *
     * @param  int|null $page (optional, default to 1)
     * @param  int|null $page_size (optional, default to 50)
     * @param  int|null $supplier (optional)
     * @param  string|null $supplier_code (optional)
     * @param  string|null $product_id (optional)
     * @param  string|null $x_forwarded_for (optional)
     * @param  string|null $x_account_id (optional)
     * @param  string|null $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPartIdMappingsV2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getPartIdMappingsV2Request($page = 1, $page_size = 50, $supplier = null, $supplier_code = null, $product_id = null, $x_forwarded_for = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getPartIdMappingsV2'][0])
    {

        if ($page !== null && $page < 1) {
            throw new \InvalidArgumentException('invalid value for "$page" when calling ExtraApi.getPartIdMappingsV2, must be bigger than or equal to 1.');
        }
        
        if ($page_size !== null && $page_size > 1000) {
            throw new \InvalidArgumentException('invalid value for "$page_size" when calling ExtraApi.getPartIdMappingsV2, must be smaller than or equal to 1000.');
        }
        if ($page_size !== null && $page_size < 1) {
            throw new \InvalidArgumentException('invalid value for "$page_size" when calling ExtraApi.getPartIdMappingsV2, must be bigger than or equal to 1.');
        }
        







        $resourcePath = '/extra/v2/part-id-mappings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page_size,
            'page_size', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $supplier,
            'supplier', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $supplier_code,
            'supplier_code', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $product_id,
            'product_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($x_forwarded_for !== null) {
            $headerParams['X-Forwarded-For'] = ObjectSerializer::toHeaderValue($x_forwarded_for);
        }
        // header params
        if ($x_account_id !== null) {
            $headerParams['x-account-id'] = ObjectSerializer::toHeaderValue($x_account_id);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getProductExtraV1ProductsProductIdGet
     *
     * Get Product
     *
     * @param  int $product_id product_id (required)
     * @param  string[]|null $expand Fields to expand in the product response (optional)
     * @param  string|null $currency currency (optional, default to 'USD')
     * @param  string|null $country country (optional, default to 'US')
     * @param  string|null $language language (optional, default to 'en')
     * @param  string|null $x_forwarded_for x_forwarded_for (optional)
     * @param  string|null $x_account_id x_account_id (optional)
     * @param  string|null $body body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getProductExtraV1ProductsProductIdGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ExtraProduct|\OpenAPI\Client\Model\HTTPValidationError
     */
    public function getProductExtraV1ProductsProductIdGet($product_id, $expand = null, $currency = 'USD', $country = 'US', $language = 'en', $x_forwarded_for = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getProductExtraV1ProductsProductIdGet'][0])
    {
        list($response) = $this->getProductExtraV1ProductsProductIdGetWithHttpInfo($product_id, $expand, $currency, $country, $language, $x_forwarded_for, $x_account_id, $body, $contentType);
        return $response;
    }

    /**
     * Operation getProductExtraV1ProductsProductIdGetWithHttpInfo
     *
     * Get Product
     *
     * @param  int $product_id (required)
     * @param  string[]|null $expand Fields to expand in the product response (optional)
     * @param  string|null $currency (optional, default to 'USD')
     * @param  string|null $country (optional, default to 'US')
     * @param  string|null $language (optional, default to 'en')
     * @param  string|null $x_forwarded_for (optional)
     * @param  string|null $x_account_id (optional)
     * @param  string|null $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getProductExtraV1ProductsProductIdGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ExtraProduct|\OpenAPI\Client\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function getProductExtraV1ProductsProductIdGetWithHttpInfo($product_id, $expand = null, $currency = 'USD', $country = 'US', $language = 'en', $x_forwarded_for = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getProductExtraV1ProductsProductIdGet'][0])
    {
        $request = $this->getProductExtraV1ProductsProductIdGetRequest($product_id, $expand, $currency, $country, $language, $x_forwarded_for, $x_account_id, $body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ExtraProduct',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\HTTPValidationError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\ExtraProduct',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ExtraProduct',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getProductExtraV1ProductsProductIdGetAsync
     *
     * Get Product
     *
     * @param  int $product_id (required)
     * @param  string[]|null $expand Fields to expand in the product response (optional)
     * @param  string|null $currency (optional, default to 'USD')
     * @param  string|null $country (optional, default to 'US')
     * @param  string|null $language (optional, default to 'en')
     * @param  string|null $x_forwarded_for (optional)
     * @param  string|null $x_account_id (optional)
     * @param  string|null $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getProductExtraV1ProductsProductIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProductExtraV1ProductsProductIdGetAsync($product_id, $expand = null, $currency = 'USD', $country = 'US', $language = 'en', $x_forwarded_for = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getProductExtraV1ProductsProductIdGet'][0])
    {
        return $this->getProductExtraV1ProductsProductIdGetAsyncWithHttpInfo($product_id, $expand, $currency, $country, $language, $x_forwarded_for, $x_account_id, $body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getProductExtraV1ProductsProductIdGetAsyncWithHttpInfo
     *
     * Get Product
     *
     * @param  int $product_id (required)
     * @param  string[]|null $expand Fields to expand in the product response (optional)
     * @param  string|null $currency (optional, default to 'USD')
     * @param  string|null $country (optional, default to 'US')
     * @param  string|null $language (optional, default to 'en')
     * @param  string|null $x_forwarded_for (optional)
     * @param  string|null $x_account_id (optional)
     * @param  string|null $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getProductExtraV1ProductsProductIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProductExtraV1ProductsProductIdGetAsyncWithHttpInfo($product_id, $expand = null, $currency = 'USD', $country = 'US', $language = 'en', $x_forwarded_for = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getProductExtraV1ProductsProductIdGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ExtraProduct';
        $request = $this->getProductExtraV1ProductsProductIdGetRequest($product_id, $expand, $currency, $country, $language, $x_forwarded_for, $x_account_id, $body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getProductExtraV1ProductsProductIdGet'
     *
     * @param  int $product_id (required)
     * @param  string[]|null $expand Fields to expand in the product response (optional)
     * @param  string|null $currency (optional, default to 'USD')
     * @param  string|null $country (optional, default to 'US')
     * @param  string|null $language (optional, default to 'en')
     * @param  string|null $x_forwarded_for (optional)
     * @param  string|null $x_account_id (optional)
     * @param  string|null $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getProductExtraV1ProductsProductIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getProductExtraV1ProductsProductIdGetRequest($product_id, $expand = null, $currency = 'USD', $country = 'US', $language = 'en', $x_forwarded_for = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getProductExtraV1ProductsProductIdGet'][0])
    {

        // verify the required parameter 'product_id' is set
        if ($product_id === null || (is_array($product_id) && count($product_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $product_id when calling getProductExtraV1ProductsProductIdGet'
            );
        }









        $resourcePath = '/extra/v1/products/{product_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $expand,
            'expand', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $currency,
            'currency', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $country,
            'country', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $language,
            'language', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($x_forwarded_for !== null) {
            $headerParams['X-Forwarded-For'] = ObjectSerializer::toHeaderValue($x_forwarded_for);
        }
        // header params
        if ($x_account_id !== null) {
            $headerParams['x-account-id'] = ObjectSerializer::toHeaderValue($x_account_id);
        }

        // path params
        if ($product_id !== null) {
            $resourcePath = str_replace(
                '{' . 'product_id' . '}',
                ObjectSerializer::toPathValue($product_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getProductMetafieldsV2
     *
     * Get Product Metafields
     *
     * @param  string $extra_id extra_id (required)
     * @param  int|null $page page (optional, default to 1)
     * @param  int|null $page_size page_size (optional, default to 100)
     * @param  string|null $x_forwarded_for x_forwarded_for (optional)
     * @param  string|null $x_account_id x_account_id (optional)
     * @param  string|null $body body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getProductMetafieldsV2'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ProductMetafieldsListResponseV2|\OpenAPI\Client\Model\HTTPValidationError
     */
    public function getProductMetafieldsV2($extra_id, $page = 1, $page_size = 100, $x_forwarded_for = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getProductMetafieldsV2'][0])
    {
        list($response) = $this->getProductMetafieldsV2WithHttpInfo($extra_id, $page, $page_size, $x_forwarded_for, $x_account_id, $body, $contentType);
        return $response;
    }

    /**
     * Operation getProductMetafieldsV2WithHttpInfo
     *
     * Get Product Metafields
     *
     * @param  string $extra_id (required)
     * @param  int|null $page (optional, default to 1)
     * @param  int|null $page_size (optional, default to 100)
     * @param  string|null $x_forwarded_for (optional)
     * @param  string|null $x_account_id (optional)
     * @param  string|null $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getProductMetafieldsV2'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ProductMetafieldsListResponseV2|\OpenAPI\Client\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function getProductMetafieldsV2WithHttpInfo($extra_id, $page = 1, $page_size = 100, $x_forwarded_for = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getProductMetafieldsV2'][0])
    {
        $request = $this->getProductMetafieldsV2Request($extra_id, $page, $page_size, $x_forwarded_for, $x_account_id, $body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ProductMetafieldsListResponseV2',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\HTTPValidationError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\ProductMetafieldsListResponseV2',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProductMetafieldsListResponseV2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getProductMetafieldsV2Async
     *
     * Get Product Metafields
     *
     * @param  string $extra_id (required)
     * @param  int|null $page (optional, default to 1)
     * @param  int|null $page_size (optional, default to 100)
     * @param  string|null $x_forwarded_for (optional)
     * @param  string|null $x_account_id (optional)
     * @param  string|null $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getProductMetafieldsV2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProductMetafieldsV2Async($extra_id, $page = 1, $page_size = 100, $x_forwarded_for = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getProductMetafieldsV2'][0])
    {
        return $this->getProductMetafieldsV2AsyncWithHttpInfo($extra_id, $page, $page_size, $x_forwarded_for, $x_account_id, $body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getProductMetafieldsV2AsyncWithHttpInfo
     *
     * Get Product Metafields
     *
     * @param  string $extra_id (required)
     * @param  int|null $page (optional, default to 1)
     * @param  int|null $page_size (optional, default to 100)
     * @param  string|null $x_forwarded_for (optional)
     * @param  string|null $x_account_id (optional)
     * @param  string|null $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getProductMetafieldsV2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProductMetafieldsV2AsyncWithHttpInfo($extra_id, $page = 1, $page_size = 100, $x_forwarded_for = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getProductMetafieldsV2'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ProductMetafieldsListResponseV2';
        $request = $this->getProductMetafieldsV2Request($extra_id, $page, $page_size, $x_forwarded_for, $x_account_id, $body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getProductMetafieldsV2'
     *
     * @param  string $extra_id (required)
     * @param  int|null $page (optional, default to 1)
     * @param  int|null $page_size (optional, default to 100)
     * @param  string|null $x_forwarded_for (optional)
     * @param  string|null $x_account_id (optional)
     * @param  string|null $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getProductMetafieldsV2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getProductMetafieldsV2Request($extra_id, $page = 1, $page_size = 100, $x_forwarded_for = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getProductMetafieldsV2'][0])
    {

        // verify the required parameter 'extra_id' is set
        if ($extra_id === null || (is_array($extra_id) && count($extra_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $extra_id when calling getProductMetafieldsV2'
            );
        }

        if ($page !== null && $page < 1) {
            throw new \InvalidArgumentException('invalid value for "$page" when calling ExtraApi.getProductMetafieldsV2, must be bigger than or equal to 1.');
        }
        
        if ($page_size !== null && $page_size > 500) {
            throw new \InvalidArgumentException('invalid value for "$page_size" when calling ExtraApi.getProductMetafieldsV2, must be smaller than or equal to 500.');
        }
        if ($page_size !== null && $page_size < 1) {
            throw new \InvalidArgumentException('invalid value for "$page_size" when calling ExtraApi.getProductMetafieldsV2, must be bigger than or equal to 1.');
        }
        




        $resourcePath = '/extra/v2/products/metafields';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page_size,
            'page_size', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $extra_id,
            'extra_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);

        // header params
        if ($x_forwarded_for !== null) {
            $headerParams['X-Forwarded-For'] = ObjectSerializer::toHeaderValue($x_forwarded_for);
        }
        // header params
        if ($x_account_id !== null) {
            $headerParams['x-account-id'] = ObjectSerializer::toHeaderValue($x_account_id);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getProductPartsExtraV1ProductsProductIdSortedPartsGet
     *
     * Get Product Parts
     *
     * @param  int $product_id product_id (required)
     * @param  int|null $days Number of days to look back (optional, default to 60)
     * @param  string|null $x_forwarded_for x_forwarded_for (optional)
     * @param  string|null $x_account_id x_account_id (optional)
     * @param  string|null $body body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getProductPartsExtraV1ProductsProductIdSortedPartsGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\VariantResponse|\OpenAPI\Client\Model\HTTPValidationError
     */
    public function getProductPartsExtraV1ProductsProductIdSortedPartsGet($product_id, $days = 60, $x_forwarded_for = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getProductPartsExtraV1ProductsProductIdSortedPartsGet'][0])
    {
        list($response) = $this->getProductPartsExtraV1ProductsProductIdSortedPartsGetWithHttpInfo($product_id, $days, $x_forwarded_for, $x_account_id, $body, $contentType);
        return $response;
    }

    /**
     * Operation getProductPartsExtraV1ProductsProductIdSortedPartsGetWithHttpInfo
     *
     * Get Product Parts
     *
     * @param  int $product_id (required)
     * @param  int|null $days Number of days to look back (optional, default to 60)
     * @param  string|null $x_forwarded_for (optional)
     * @param  string|null $x_account_id (optional)
     * @param  string|null $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getProductPartsExtraV1ProductsProductIdSortedPartsGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\VariantResponse|\OpenAPI\Client\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function getProductPartsExtraV1ProductsProductIdSortedPartsGetWithHttpInfo($product_id, $days = 60, $x_forwarded_for = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getProductPartsExtraV1ProductsProductIdSortedPartsGet'][0])
    {
        $request = $this->getProductPartsExtraV1ProductsProductIdSortedPartsGetRequest($product_id, $days, $x_forwarded_for, $x_account_id, $body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\VariantResponse',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\HTTPValidationError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\VariantResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\VariantResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getProductPartsExtraV1ProductsProductIdSortedPartsGetAsync
     *
     * Get Product Parts
     *
     * @param  int $product_id (required)
     * @param  int|null $days Number of days to look back (optional, default to 60)
     * @param  string|null $x_forwarded_for (optional)
     * @param  string|null $x_account_id (optional)
     * @param  string|null $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getProductPartsExtraV1ProductsProductIdSortedPartsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProductPartsExtraV1ProductsProductIdSortedPartsGetAsync($product_id, $days = 60, $x_forwarded_for = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getProductPartsExtraV1ProductsProductIdSortedPartsGet'][0])
    {
        return $this->getProductPartsExtraV1ProductsProductIdSortedPartsGetAsyncWithHttpInfo($product_id, $days, $x_forwarded_for, $x_account_id, $body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getProductPartsExtraV1ProductsProductIdSortedPartsGetAsyncWithHttpInfo
     *
     * Get Product Parts
     *
     * @param  int $product_id (required)
     * @param  int|null $days Number of days to look back (optional, default to 60)
     * @param  string|null $x_forwarded_for (optional)
     * @param  string|null $x_account_id (optional)
     * @param  string|null $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getProductPartsExtraV1ProductsProductIdSortedPartsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProductPartsExtraV1ProductsProductIdSortedPartsGetAsyncWithHttpInfo($product_id, $days = 60, $x_forwarded_for = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getProductPartsExtraV1ProductsProductIdSortedPartsGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\VariantResponse';
        $request = $this->getProductPartsExtraV1ProductsProductIdSortedPartsGetRequest($product_id, $days, $x_forwarded_for, $x_account_id, $body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getProductPartsExtraV1ProductsProductIdSortedPartsGet'
     *
     * @param  int $product_id (required)
     * @param  int|null $days Number of days to look back (optional, default to 60)
     * @param  string|null $x_forwarded_for (optional)
     * @param  string|null $x_account_id (optional)
     * @param  string|null $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getProductPartsExtraV1ProductsProductIdSortedPartsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getProductPartsExtraV1ProductsProductIdSortedPartsGetRequest($product_id, $days = 60, $x_forwarded_for = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getProductPartsExtraV1ProductsProductIdSortedPartsGet'][0])
    {

        // verify the required parameter 'product_id' is set
        if ($product_id === null || (is_array($product_id) && count($product_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $product_id when calling getProductPartsExtraV1ProductsProductIdSortedPartsGet'
            );
        }






        $resourcePath = '/extra/v1/products/{product_id}/sorted-parts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $days,
            'days', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($x_forwarded_for !== null) {
            $headerParams['X-Forwarded-For'] = ObjectSerializer::toHeaderValue($x_forwarded_for);
        }
        // header params
        if ($x_account_id !== null) {
            $headerParams['x-account-id'] = ObjectSerializer::toHeaderValue($x_account_id);
        }

        // path params
        if ($product_id !== null) {
            $resourcePath = str_replace(
                '{' . 'product_id' . '}',
                ObjectSerializer::toPathValue($product_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getProductV2
     *
     * Get Product
     *
     * @param  int $product_id product_id (required)
     * @param  string[]|null $expand Fields to expand in the product response (optional)
     * @param  string|null $currency currency (optional, default to 'USD')
     * @param  string|null $country country (optional, default to 'US')
     * @param  string|null $language language (optional, default to 'en')
     * @param  string|null $x_forwarded_for x_forwarded_for (optional)
     * @param  string|null $x_account_id x_account_id (optional)
     * @param  string|null $body body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getProductV2'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ExtraProductV2|\OpenAPI\Client\Model\HTTPValidationError
     */
    public function getProductV2($product_id, $expand = null, $currency = 'USD', $country = 'US', $language = 'en', $x_forwarded_for = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getProductV2'][0])
    {
        list($response) = $this->getProductV2WithHttpInfo($product_id, $expand, $currency, $country, $language, $x_forwarded_for, $x_account_id, $body, $contentType);
        return $response;
    }

    /**
     * Operation getProductV2WithHttpInfo
     *
     * Get Product
     *
     * @param  int $product_id (required)
     * @param  string[]|null $expand Fields to expand in the product response (optional)
     * @param  string|null $currency (optional, default to 'USD')
     * @param  string|null $country (optional, default to 'US')
     * @param  string|null $language (optional, default to 'en')
     * @param  string|null $x_forwarded_for (optional)
     * @param  string|null $x_account_id (optional)
     * @param  string|null $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getProductV2'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ExtraProductV2|\OpenAPI\Client\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function getProductV2WithHttpInfo($product_id, $expand = null, $currency = 'USD', $country = 'US', $language = 'en', $x_forwarded_for = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getProductV2'][0])
    {
        $request = $this->getProductV2Request($product_id, $expand, $currency, $country, $language, $x_forwarded_for, $x_account_id, $body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ExtraProductV2',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\HTTPValidationError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\ExtraProductV2',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ExtraProductV2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getProductV2Async
     *
     * Get Product
     *
     * @param  int $product_id (required)
     * @param  string[]|null $expand Fields to expand in the product response (optional)
     * @param  string|null $currency (optional, default to 'USD')
     * @param  string|null $country (optional, default to 'US')
     * @param  string|null $language (optional, default to 'en')
     * @param  string|null $x_forwarded_for (optional)
     * @param  string|null $x_account_id (optional)
     * @param  string|null $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getProductV2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProductV2Async($product_id, $expand = null, $currency = 'USD', $country = 'US', $language = 'en', $x_forwarded_for = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getProductV2'][0])
    {
        return $this->getProductV2AsyncWithHttpInfo($product_id, $expand, $currency, $country, $language, $x_forwarded_for, $x_account_id, $body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getProductV2AsyncWithHttpInfo
     *
     * Get Product
     *
     * @param  int $product_id (required)
     * @param  string[]|null $expand Fields to expand in the product response (optional)
     * @param  string|null $currency (optional, default to 'USD')
     * @param  string|null $country (optional, default to 'US')
     * @param  string|null $language (optional, default to 'en')
     * @param  string|null $x_forwarded_for (optional)
     * @param  string|null $x_account_id (optional)
     * @param  string|null $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getProductV2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProductV2AsyncWithHttpInfo($product_id, $expand = null, $currency = 'USD', $country = 'US', $language = 'en', $x_forwarded_for = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getProductV2'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ExtraProductV2';
        $request = $this->getProductV2Request($product_id, $expand, $currency, $country, $language, $x_forwarded_for, $x_account_id, $body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getProductV2'
     *
     * @param  int $product_id (required)
     * @param  string[]|null $expand Fields to expand in the product response (optional)
     * @param  string|null $currency (optional, default to 'USD')
     * @param  string|null $country (optional, default to 'US')
     * @param  string|null $language (optional, default to 'en')
     * @param  string|null $x_forwarded_for (optional)
     * @param  string|null $x_account_id (optional)
     * @param  string|null $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getProductV2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getProductV2Request($product_id, $expand = null, $currency = 'USD', $country = 'US', $language = 'en', $x_forwarded_for = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getProductV2'][0])
    {

        // verify the required parameter 'product_id' is set
        if ($product_id === null || (is_array($product_id) && count($product_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $product_id when calling getProductV2'
            );
        }









        $resourcePath = '/extra/v2/products/{product_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $expand,
            'expand', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $currency,
            'currency', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $country,
            'country', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $language,
            'language', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($x_forwarded_for !== null) {
            $headerParams['X-Forwarded-For'] = ObjectSerializer::toHeaderValue($x_forwarded_for);
        }
        // header params
        if ($x_account_id !== null) {
            $headerParams['x-account-id'] = ObjectSerializer::toHeaderValue($x_account_id);
        }

        // path params
        if ($product_id !== null) {
            $resourcePath = str_replace(
                '{' . 'product_id' . '}',
                ObjectSerializer::toPathValue($product_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getProducts
     *
     * Get Products
     *
     * @param  int|null $supplier supplier (optional)
     * @param  string|null $supplier_code supplier_code (optional)
     * @param  string|null $product_id product_id (optional)
     * @param  string|null $extra_id extra_id (optional)
     * @param  int|null $brand brand (optional)
     * @param  bool|null $export export (optional)
     * @param  bool|null $is_caution is_caution (optional)
     * @param  bool|null $is_closeout is_closeout (optional)
     * @param  string|null $country_of_origin country_of_origin (optional)
     * @param  string|null $primary_material primary_material (optional)
     * @param  int|null $lead_time lead_time (optional)
     * @param  string|null $lead_time__range lead_time__range (optional)
     * @param  string|null $min_qty__range min_qty__range (optional)
     * @param  bool|null $is_rush_service is_rush_service (optional)
     * @param  int|null $rush_service_lead_time rush_service_lead_time (optional)
     * @param  bool|null $is_on_demand is_on_demand (optional)
     * @param  string|null $main_category main_category (optional)
     * @param  string|null $list_price__range list_price__range (optional)
     * @param  \OpenAPI\Client\Model\ApparelStyle|null $apparel_style apparel_style (optional)
     * @param  int|null $shop shop (optional)
     * @param  string|null $search search (optional)
     * @param  string|null $ordering ordering (optional)
     * @param  int|null $limit limit (optional, default to 10)
     * @param  int|null $offset offset (optional, default to 0)
     * @param  string|null $x_forwarded_for x_forwarded_for (optional)
     * @param  string|null $x_account_id x_account_id (optional)
     * @param  string|null $body body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getProducts'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ProductListResponse|\OpenAPI\Client\Model\HTTPValidationError
     */
    public function getProducts($supplier = null, $supplier_code = null, $product_id = null, $extra_id = null, $brand = null, $export = null, $is_caution = null, $is_closeout = null, $country_of_origin = null, $primary_material = null, $lead_time = null, $lead_time__range = null, $min_qty__range = null, $is_rush_service = null, $rush_service_lead_time = null, $is_on_demand = null, $main_category = null, $list_price__range = null, $apparel_style = null, $shop = null, $search = null, $ordering = null, $limit = 10, $offset = 0, $x_forwarded_for = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getProducts'][0])
    {
        list($response) = $this->getProductsWithHttpInfo($supplier, $supplier_code, $product_id, $extra_id, $brand, $export, $is_caution, $is_closeout, $country_of_origin, $primary_material, $lead_time, $lead_time__range, $min_qty__range, $is_rush_service, $rush_service_lead_time, $is_on_demand, $main_category, $list_price__range, $apparel_style, $shop, $search, $ordering, $limit, $offset, $x_forwarded_for, $x_account_id, $body, $contentType);
        return $response;
    }

    /**
     * Operation getProductsWithHttpInfo
     *
     * Get Products
     *
     * @param  int|null $supplier (optional)
     * @param  string|null $supplier_code (optional)
     * @param  string|null $product_id (optional)
     * @param  string|null $extra_id (optional)
     * @param  int|null $brand (optional)
     * @param  bool|null $export (optional)
     * @param  bool|null $is_caution (optional)
     * @param  bool|null $is_closeout (optional)
     * @param  string|null $country_of_origin (optional)
     * @param  string|null $primary_material (optional)
     * @param  int|null $lead_time (optional)
     * @param  string|null $lead_time__range (optional)
     * @param  string|null $min_qty__range (optional)
     * @param  bool|null $is_rush_service (optional)
     * @param  int|null $rush_service_lead_time (optional)
     * @param  bool|null $is_on_demand (optional)
     * @param  string|null $main_category (optional)
     * @param  string|null $list_price__range (optional)
     * @param  \OpenAPI\Client\Model\ApparelStyle|null $apparel_style (optional)
     * @param  int|null $shop (optional)
     * @param  string|null $search (optional)
     * @param  string|null $ordering (optional)
     * @param  int|null $limit (optional, default to 10)
     * @param  int|null $offset (optional, default to 0)
     * @param  string|null $x_forwarded_for (optional)
     * @param  string|null $x_account_id (optional)
     * @param  string|null $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getProducts'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ProductListResponse|\OpenAPI\Client\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function getProductsWithHttpInfo($supplier = null, $supplier_code = null, $product_id = null, $extra_id = null, $brand = null, $export = null, $is_caution = null, $is_closeout = null, $country_of_origin = null, $primary_material = null, $lead_time = null, $lead_time__range = null, $min_qty__range = null, $is_rush_service = null, $rush_service_lead_time = null, $is_on_demand = null, $main_category = null, $list_price__range = null, $apparel_style = null, $shop = null, $search = null, $ordering = null, $limit = 10, $offset = 0, $x_forwarded_for = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getProducts'][0])
    {
        $request = $this->getProductsRequest($supplier, $supplier_code, $product_id, $extra_id, $brand, $export, $is_caution, $is_closeout, $country_of_origin, $primary_material, $lead_time, $lead_time__range, $min_qty__range, $is_rush_service, $rush_service_lead_time, $is_on_demand, $main_category, $list_price__range, $apparel_style, $shop, $search, $ordering, $limit, $offset, $x_forwarded_for, $x_account_id, $body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ProductListResponse',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\HTTPValidationError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\ProductListResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProductListResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getProductsAsync
     *
     * Get Products
     *
     * @param  int|null $supplier (optional)
     * @param  string|null $supplier_code (optional)
     * @param  string|null $product_id (optional)
     * @param  string|null $extra_id (optional)
     * @param  int|null $brand (optional)
     * @param  bool|null $export (optional)
     * @param  bool|null $is_caution (optional)
     * @param  bool|null $is_closeout (optional)
     * @param  string|null $country_of_origin (optional)
     * @param  string|null $primary_material (optional)
     * @param  int|null $lead_time (optional)
     * @param  string|null $lead_time__range (optional)
     * @param  string|null $min_qty__range (optional)
     * @param  bool|null $is_rush_service (optional)
     * @param  int|null $rush_service_lead_time (optional)
     * @param  bool|null $is_on_demand (optional)
     * @param  string|null $main_category (optional)
     * @param  string|null $list_price__range (optional)
     * @param  \OpenAPI\Client\Model\ApparelStyle|null $apparel_style (optional)
     * @param  int|null $shop (optional)
     * @param  string|null $search (optional)
     * @param  string|null $ordering (optional)
     * @param  int|null $limit (optional, default to 10)
     * @param  int|null $offset (optional, default to 0)
     * @param  string|null $x_forwarded_for (optional)
     * @param  string|null $x_account_id (optional)
     * @param  string|null $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getProducts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProductsAsync($supplier = null, $supplier_code = null, $product_id = null, $extra_id = null, $brand = null, $export = null, $is_caution = null, $is_closeout = null, $country_of_origin = null, $primary_material = null, $lead_time = null, $lead_time__range = null, $min_qty__range = null, $is_rush_service = null, $rush_service_lead_time = null, $is_on_demand = null, $main_category = null, $list_price__range = null, $apparel_style = null, $shop = null, $search = null, $ordering = null, $limit = 10, $offset = 0, $x_forwarded_for = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getProducts'][0])
    {
        return $this->getProductsAsyncWithHttpInfo($supplier, $supplier_code, $product_id, $extra_id, $brand, $export, $is_caution, $is_closeout, $country_of_origin, $primary_material, $lead_time, $lead_time__range, $min_qty__range, $is_rush_service, $rush_service_lead_time, $is_on_demand, $main_category, $list_price__range, $apparel_style, $shop, $search, $ordering, $limit, $offset, $x_forwarded_for, $x_account_id, $body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getProductsAsyncWithHttpInfo
     *
     * Get Products
     *
     * @param  int|null $supplier (optional)
     * @param  string|null $supplier_code (optional)
     * @param  string|null $product_id (optional)
     * @param  string|null $extra_id (optional)
     * @param  int|null $brand (optional)
     * @param  bool|null $export (optional)
     * @param  bool|null $is_caution (optional)
     * @param  bool|null $is_closeout (optional)
     * @param  string|null $country_of_origin (optional)
     * @param  string|null $primary_material (optional)
     * @param  int|null $lead_time (optional)
     * @param  string|null $lead_time__range (optional)
     * @param  string|null $min_qty__range (optional)
     * @param  bool|null $is_rush_service (optional)
     * @param  int|null $rush_service_lead_time (optional)
     * @param  bool|null $is_on_demand (optional)
     * @param  string|null $main_category (optional)
     * @param  string|null $list_price__range (optional)
     * @param  \OpenAPI\Client\Model\ApparelStyle|null $apparel_style (optional)
     * @param  int|null $shop (optional)
     * @param  string|null $search (optional)
     * @param  string|null $ordering (optional)
     * @param  int|null $limit (optional, default to 10)
     * @param  int|null $offset (optional, default to 0)
     * @param  string|null $x_forwarded_for (optional)
     * @param  string|null $x_account_id (optional)
     * @param  string|null $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getProducts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProductsAsyncWithHttpInfo($supplier = null, $supplier_code = null, $product_id = null, $extra_id = null, $brand = null, $export = null, $is_caution = null, $is_closeout = null, $country_of_origin = null, $primary_material = null, $lead_time = null, $lead_time__range = null, $min_qty__range = null, $is_rush_service = null, $rush_service_lead_time = null, $is_on_demand = null, $main_category = null, $list_price__range = null, $apparel_style = null, $shop = null, $search = null, $ordering = null, $limit = 10, $offset = 0, $x_forwarded_for = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getProducts'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ProductListResponse';
        $request = $this->getProductsRequest($supplier, $supplier_code, $product_id, $extra_id, $brand, $export, $is_caution, $is_closeout, $country_of_origin, $primary_material, $lead_time, $lead_time__range, $min_qty__range, $is_rush_service, $rush_service_lead_time, $is_on_demand, $main_category, $list_price__range, $apparel_style, $shop, $search, $ordering, $limit, $offset, $x_forwarded_for, $x_account_id, $body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getProducts'
     *
     * @param  int|null $supplier (optional)
     * @param  string|null $supplier_code (optional)
     * @param  string|null $product_id (optional)
     * @param  string|null $extra_id (optional)
     * @param  int|null $brand (optional)
     * @param  bool|null $export (optional)
     * @param  bool|null $is_caution (optional)
     * @param  bool|null $is_closeout (optional)
     * @param  string|null $country_of_origin (optional)
     * @param  string|null $primary_material (optional)
     * @param  int|null $lead_time (optional)
     * @param  string|null $lead_time__range (optional)
     * @param  string|null $min_qty__range (optional)
     * @param  bool|null $is_rush_service (optional)
     * @param  int|null $rush_service_lead_time (optional)
     * @param  bool|null $is_on_demand (optional)
     * @param  string|null $main_category (optional)
     * @param  string|null $list_price__range (optional)
     * @param  \OpenAPI\Client\Model\ApparelStyle|null $apparel_style (optional)
     * @param  int|null $shop (optional)
     * @param  string|null $search (optional)
     * @param  string|null $ordering (optional)
     * @param  int|null $limit (optional, default to 10)
     * @param  int|null $offset (optional, default to 0)
     * @param  string|null $x_forwarded_for (optional)
     * @param  string|null $x_account_id (optional)
     * @param  string|null $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getProducts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getProductsRequest($supplier = null, $supplier_code = null, $product_id = null, $extra_id = null, $brand = null, $export = null, $is_caution = null, $is_closeout = null, $country_of_origin = null, $primary_material = null, $lead_time = null, $lead_time__range = null, $min_qty__range = null, $is_rush_service = null, $rush_service_lead_time = null, $is_on_demand = null, $main_category = null, $list_price__range = null, $apparel_style = null, $shop = null, $search = null, $ordering = null, $limit = 10, $offset = 0, $x_forwarded_for = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getProducts'][0])
    {























        if ($limit !== null && $limit > 100) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling ExtraApi.getProducts, must be smaller than or equal to 100.');
        }
        if ($limit !== null && $limit < 1) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling ExtraApi.getProducts, must be bigger than or equal to 1.');
        }
        
        if ($offset !== null && $offset < 0) {
            throw new \InvalidArgumentException('invalid value for "$offset" when calling ExtraApi.getProducts, must be bigger than or equal to 0.');
        }
        




        $resourcePath = '/extra/v1/products';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $supplier,
            'supplier', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $supplier_code,
            'supplier_code', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $product_id,
            'product_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $extra_id,
            'extra_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $brand,
            'brand', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $export,
            'export', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_caution,
            'is_caution', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_closeout,
            'is_closeout', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $country_of_origin,
            'country_of_origin', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $primary_material,
            'primary_material', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $lead_time,
            'lead_time', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $lead_time__range,
            'lead_time__range', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_qty__range,
            'min_qty__range', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_rush_service,
            'is_rush_service', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rush_service_lead_time,
            'rush_service_lead_time', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_on_demand,
            'is_on_demand', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $main_category,
            'main_category', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $list_price__range,
            'list_price__range', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $apparel_style,
            'apparel_style', // param base name
            'ApparelStyle', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $shop,
            'shop', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $search,
            'search', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ordering,
            'ordering', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($x_forwarded_for !== null) {
            $headerParams['X-Forwarded-For'] = ObjectSerializer::toHeaderValue($x_forwarded_for);
        }
        // header params
        if ($x_account_id !== null) {
            $headerParams['x-account-id'] = ObjectSerializer::toHeaderValue($x_account_id);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getProductsV2
     *
     * Get Products
     *
     * @param  int|null $page page (optional, default to 1)
     * @param  int|null $page_size page_size (optional, default to 10)
     * @param  int|null $supplier supplier (optional)
     * @param  string|null $supplier_code supplier_code (optional)
     * @param  string|null $product_id product_id (optional)
     * @param  string|null $extra_id extra_id (optional)
     * @param  int|null $brand brand (optional)
     * @param  bool|null $export export (optional)
     * @param  bool|null $is_caution is_caution (optional)
     * @param  bool|null $is_closeout is_closeout (optional)
     * @param  string|null $country_of_origin country_of_origin (optional)
     * @param  string|null $primary_material primary_material (optional)
     * @param  int|null $lead_time lead_time (optional)
     * @param  string|null $lead_time__range lead_time__range (optional)
     * @param  string|null $min_qty__range min_qty__range (optional)
     * @param  bool|null $is_rush_service is_rush_service (optional)
     * @param  int|null $rush_service_lead_time rush_service_lead_time (optional)
     * @param  bool|null $is_on_demand is_on_demand (optional)
     * @param  string|null $main_category main_category (optional)
     * @param  string|null $list_price__range list_price__range (optional)
     * @param  \OpenAPI\Client\Model\ApparelStyle|null $apparel_style apparel_style (optional)
     * @param  int|null $shop shop (optional)
     * @param  string|null $search search (optional)
     * @param  string|null $ordering ordering (optional)
     * @param  string|null $x_forwarded_for x_forwarded_for (optional)
     * @param  string|null $x_account_id x_account_id (optional)
     * @param  string|null $body body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getProductsV2'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ProductListResponseV2|\OpenAPI\Client\Model\HTTPValidationError
     */
    public function getProductsV2($page = 1, $page_size = 10, $supplier = null, $supplier_code = null, $product_id = null, $extra_id = null, $brand = null, $export = null, $is_caution = null, $is_closeout = null, $country_of_origin = null, $primary_material = null, $lead_time = null, $lead_time__range = null, $min_qty__range = null, $is_rush_service = null, $rush_service_lead_time = null, $is_on_demand = null, $main_category = null, $list_price__range = null, $apparel_style = null, $shop = null, $search = null, $ordering = null, $x_forwarded_for = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getProductsV2'][0])
    {
        list($response) = $this->getProductsV2WithHttpInfo($page, $page_size, $supplier, $supplier_code, $product_id, $extra_id, $brand, $export, $is_caution, $is_closeout, $country_of_origin, $primary_material, $lead_time, $lead_time__range, $min_qty__range, $is_rush_service, $rush_service_lead_time, $is_on_demand, $main_category, $list_price__range, $apparel_style, $shop, $search, $ordering, $x_forwarded_for, $x_account_id, $body, $contentType);
        return $response;
    }

    /**
     * Operation getProductsV2WithHttpInfo
     *
     * Get Products
     *
     * @param  int|null $page (optional, default to 1)
     * @param  int|null $page_size (optional, default to 10)
     * @param  int|null $supplier (optional)
     * @param  string|null $supplier_code (optional)
     * @param  string|null $product_id (optional)
     * @param  string|null $extra_id (optional)
     * @param  int|null $brand (optional)
     * @param  bool|null $export (optional)
     * @param  bool|null $is_caution (optional)
     * @param  bool|null $is_closeout (optional)
     * @param  string|null $country_of_origin (optional)
     * @param  string|null $primary_material (optional)
     * @param  int|null $lead_time (optional)
     * @param  string|null $lead_time__range (optional)
     * @param  string|null $min_qty__range (optional)
     * @param  bool|null $is_rush_service (optional)
     * @param  int|null $rush_service_lead_time (optional)
     * @param  bool|null $is_on_demand (optional)
     * @param  string|null $main_category (optional)
     * @param  string|null $list_price__range (optional)
     * @param  \OpenAPI\Client\Model\ApparelStyle|null $apparel_style (optional)
     * @param  int|null $shop (optional)
     * @param  string|null $search (optional)
     * @param  string|null $ordering (optional)
     * @param  string|null $x_forwarded_for (optional)
     * @param  string|null $x_account_id (optional)
     * @param  string|null $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getProductsV2'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ProductListResponseV2|\OpenAPI\Client\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function getProductsV2WithHttpInfo($page = 1, $page_size = 10, $supplier = null, $supplier_code = null, $product_id = null, $extra_id = null, $brand = null, $export = null, $is_caution = null, $is_closeout = null, $country_of_origin = null, $primary_material = null, $lead_time = null, $lead_time__range = null, $min_qty__range = null, $is_rush_service = null, $rush_service_lead_time = null, $is_on_demand = null, $main_category = null, $list_price__range = null, $apparel_style = null, $shop = null, $search = null, $ordering = null, $x_forwarded_for = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getProductsV2'][0])
    {
        $request = $this->getProductsV2Request($page, $page_size, $supplier, $supplier_code, $product_id, $extra_id, $brand, $export, $is_caution, $is_closeout, $country_of_origin, $primary_material, $lead_time, $lead_time__range, $min_qty__range, $is_rush_service, $rush_service_lead_time, $is_on_demand, $main_category, $list_price__range, $apparel_style, $shop, $search, $ordering, $x_forwarded_for, $x_account_id, $body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ProductListResponseV2',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\HTTPValidationError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\ProductListResponseV2',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProductListResponseV2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getProductsV2Async
     *
     * Get Products
     *
     * @param  int|null $page (optional, default to 1)
     * @param  int|null $page_size (optional, default to 10)
     * @param  int|null $supplier (optional)
     * @param  string|null $supplier_code (optional)
     * @param  string|null $product_id (optional)
     * @param  string|null $extra_id (optional)
     * @param  int|null $brand (optional)
     * @param  bool|null $export (optional)
     * @param  bool|null $is_caution (optional)
     * @param  bool|null $is_closeout (optional)
     * @param  string|null $country_of_origin (optional)
     * @param  string|null $primary_material (optional)
     * @param  int|null $lead_time (optional)
     * @param  string|null $lead_time__range (optional)
     * @param  string|null $min_qty__range (optional)
     * @param  bool|null $is_rush_service (optional)
     * @param  int|null $rush_service_lead_time (optional)
     * @param  bool|null $is_on_demand (optional)
     * @param  string|null $main_category (optional)
     * @param  string|null $list_price__range (optional)
     * @param  \OpenAPI\Client\Model\ApparelStyle|null $apparel_style (optional)
     * @param  int|null $shop (optional)
     * @param  string|null $search (optional)
     * @param  string|null $ordering (optional)
     * @param  string|null $x_forwarded_for (optional)
     * @param  string|null $x_account_id (optional)
     * @param  string|null $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getProductsV2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProductsV2Async($page = 1, $page_size = 10, $supplier = null, $supplier_code = null, $product_id = null, $extra_id = null, $brand = null, $export = null, $is_caution = null, $is_closeout = null, $country_of_origin = null, $primary_material = null, $lead_time = null, $lead_time__range = null, $min_qty__range = null, $is_rush_service = null, $rush_service_lead_time = null, $is_on_demand = null, $main_category = null, $list_price__range = null, $apparel_style = null, $shop = null, $search = null, $ordering = null, $x_forwarded_for = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getProductsV2'][0])
    {
        return $this->getProductsV2AsyncWithHttpInfo($page, $page_size, $supplier, $supplier_code, $product_id, $extra_id, $brand, $export, $is_caution, $is_closeout, $country_of_origin, $primary_material, $lead_time, $lead_time__range, $min_qty__range, $is_rush_service, $rush_service_lead_time, $is_on_demand, $main_category, $list_price__range, $apparel_style, $shop, $search, $ordering, $x_forwarded_for, $x_account_id, $body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getProductsV2AsyncWithHttpInfo
     *
     * Get Products
     *
     * @param  int|null $page (optional, default to 1)
     * @param  int|null $page_size (optional, default to 10)
     * @param  int|null $supplier (optional)
     * @param  string|null $supplier_code (optional)
     * @param  string|null $product_id (optional)
     * @param  string|null $extra_id (optional)
     * @param  int|null $brand (optional)
     * @param  bool|null $export (optional)
     * @param  bool|null $is_caution (optional)
     * @param  bool|null $is_closeout (optional)
     * @param  string|null $country_of_origin (optional)
     * @param  string|null $primary_material (optional)
     * @param  int|null $lead_time (optional)
     * @param  string|null $lead_time__range (optional)
     * @param  string|null $min_qty__range (optional)
     * @param  bool|null $is_rush_service (optional)
     * @param  int|null $rush_service_lead_time (optional)
     * @param  bool|null $is_on_demand (optional)
     * @param  string|null $main_category (optional)
     * @param  string|null $list_price__range (optional)
     * @param  \OpenAPI\Client\Model\ApparelStyle|null $apparel_style (optional)
     * @param  int|null $shop (optional)
     * @param  string|null $search (optional)
     * @param  string|null $ordering (optional)
     * @param  string|null $x_forwarded_for (optional)
     * @param  string|null $x_account_id (optional)
     * @param  string|null $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getProductsV2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProductsV2AsyncWithHttpInfo($page = 1, $page_size = 10, $supplier = null, $supplier_code = null, $product_id = null, $extra_id = null, $brand = null, $export = null, $is_caution = null, $is_closeout = null, $country_of_origin = null, $primary_material = null, $lead_time = null, $lead_time__range = null, $min_qty__range = null, $is_rush_service = null, $rush_service_lead_time = null, $is_on_demand = null, $main_category = null, $list_price__range = null, $apparel_style = null, $shop = null, $search = null, $ordering = null, $x_forwarded_for = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getProductsV2'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ProductListResponseV2';
        $request = $this->getProductsV2Request($page, $page_size, $supplier, $supplier_code, $product_id, $extra_id, $brand, $export, $is_caution, $is_closeout, $country_of_origin, $primary_material, $lead_time, $lead_time__range, $min_qty__range, $is_rush_service, $rush_service_lead_time, $is_on_demand, $main_category, $list_price__range, $apparel_style, $shop, $search, $ordering, $x_forwarded_for, $x_account_id, $body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getProductsV2'
     *
     * @param  int|null $page (optional, default to 1)
     * @param  int|null $page_size (optional, default to 10)
     * @param  int|null $supplier (optional)
     * @param  string|null $supplier_code (optional)
     * @param  string|null $product_id (optional)
     * @param  string|null $extra_id (optional)
     * @param  int|null $brand (optional)
     * @param  bool|null $export (optional)
     * @param  bool|null $is_caution (optional)
     * @param  bool|null $is_closeout (optional)
     * @param  string|null $country_of_origin (optional)
     * @param  string|null $primary_material (optional)
     * @param  int|null $lead_time (optional)
     * @param  string|null $lead_time__range (optional)
     * @param  string|null $min_qty__range (optional)
     * @param  bool|null $is_rush_service (optional)
     * @param  int|null $rush_service_lead_time (optional)
     * @param  bool|null $is_on_demand (optional)
     * @param  string|null $main_category (optional)
     * @param  string|null $list_price__range (optional)
     * @param  \OpenAPI\Client\Model\ApparelStyle|null $apparel_style (optional)
     * @param  int|null $shop (optional)
     * @param  string|null $search (optional)
     * @param  string|null $ordering (optional)
     * @param  string|null $x_forwarded_for (optional)
     * @param  string|null $x_account_id (optional)
     * @param  string|null $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getProductsV2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getProductsV2Request($page = 1, $page_size = 10, $supplier = null, $supplier_code = null, $product_id = null, $extra_id = null, $brand = null, $export = null, $is_caution = null, $is_closeout = null, $country_of_origin = null, $primary_material = null, $lead_time = null, $lead_time__range = null, $min_qty__range = null, $is_rush_service = null, $rush_service_lead_time = null, $is_on_demand = null, $main_category = null, $list_price__range = null, $apparel_style = null, $shop = null, $search = null, $ordering = null, $x_forwarded_for = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getProductsV2'][0])
    {

        if ($page !== null && $page < 1) {
            throw new \InvalidArgumentException('invalid value for "$page" when calling ExtraApi.getProductsV2, must be bigger than or equal to 1.');
        }
        
        if ($page_size !== null && $page_size > 100) {
            throw new \InvalidArgumentException('invalid value for "$page_size" when calling ExtraApi.getProductsV2, must be smaller than or equal to 100.');
        }
        if ($page_size !== null && $page_size < 1) {
            throw new \InvalidArgumentException('invalid value for "$page_size" when calling ExtraApi.getProductsV2, must be bigger than or equal to 1.');
        }
        


























        $resourcePath = '/extra/v2/products';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page_size,
            'page_size', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $supplier,
            'supplier', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $supplier_code,
            'supplier_code', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $product_id,
            'product_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $extra_id,
            'extra_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $brand,
            'brand', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $export,
            'export', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_caution,
            'is_caution', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_closeout,
            'is_closeout', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $country_of_origin,
            'country_of_origin', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $primary_material,
            'primary_material', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $lead_time,
            'lead_time', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $lead_time__range,
            'lead_time__range', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_qty__range,
            'min_qty__range', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_rush_service,
            'is_rush_service', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rush_service_lead_time,
            'rush_service_lead_time', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_on_demand,
            'is_on_demand', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $main_category,
            'main_category', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $list_price__range,
            'list_price__range', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $apparel_style,
            'apparel_style', // param base name
            'ApparelStyle', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $shop,
            'shop', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $search,
            'search', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ordering,
            'ordering', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($x_forwarded_for !== null) {
            $headerParams['X-Forwarded-For'] = ObjectSerializer::toHeaderValue($x_forwarded_for);
        }
        // header params
        if ($x_account_id !== null) {
            $headerParams['x-account-id'] = ObjectSerializer::toHeaderValue($x_account_id);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSuppliersExtraV1SuppliersGet
     *
     * Get Suppliers
     *
     * @param  bool|null $shopify_ready Filter by Shopify readiness (optional)
     * @param  bool|null $credentials_available Filter by credentials availability (optional)
     * @param  string|null $x_forwarded_for x_forwarded_for (optional)
     * @param  string|null $x_account_id x_account_id (optional)
     * @param  string|null $body body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSuppliersExtraV1SuppliersGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SuppliersResponse|\OpenAPI\Client\Model\HTTPValidationError
     */
    public function getSuppliersExtraV1SuppliersGet($shopify_ready = null, $credentials_available = null, $x_forwarded_for = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getSuppliersExtraV1SuppliersGet'][0])
    {
        list($response) = $this->getSuppliersExtraV1SuppliersGetWithHttpInfo($shopify_ready, $credentials_available, $x_forwarded_for, $x_account_id, $body, $contentType);
        return $response;
    }

    /**
     * Operation getSuppliersExtraV1SuppliersGetWithHttpInfo
     *
     * Get Suppliers
     *
     * @param  bool|null $shopify_ready Filter by Shopify readiness (optional)
     * @param  bool|null $credentials_available Filter by credentials availability (optional)
     * @param  string|null $x_forwarded_for (optional)
     * @param  string|null $x_account_id (optional)
     * @param  string|null $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSuppliersExtraV1SuppliersGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SuppliersResponse|\OpenAPI\Client\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function getSuppliersExtraV1SuppliersGetWithHttpInfo($shopify_ready = null, $credentials_available = null, $x_forwarded_for = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getSuppliersExtraV1SuppliersGet'][0])
    {
        $request = $this->getSuppliersExtraV1SuppliersGetRequest($shopify_ready, $credentials_available, $x_forwarded_for, $x_account_id, $body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\SuppliersResponse',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\HTTPValidationError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\SuppliersResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SuppliersResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getSuppliersExtraV1SuppliersGetAsync
     *
     * Get Suppliers
     *
     * @param  bool|null $shopify_ready Filter by Shopify readiness (optional)
     * @param  bool|null $credentials_available Filter by credentials availability (optional)
     * @param  string|null $x_forwarded_for (optional)
     * @param  string|null $x_account_id (optional)
     * @param  string|null $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSuppliersExtraV1SuppliersGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSuppliersExtraV1SuppliersGetAsync($shopify_ready = null, $credentials_available = null, $x_forwarded_for = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getSuppliersExtraV1SuppliersGet'][0])
    {
        return $this->getSuppliersExtraV1SuppliersGetAsyncWithHttpInfo($shopify_ready, $credentials_available, $x_forwarded_for, $x_account_id, $body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSuppliersExtraV1SuppliersGetAsyncWithHttpInfo
     *
     * Get Suppliers
     *
     * @param  bool|null $shopify_ready Filter by Shopify readiness (optional)
     * @param  bool|null $credentials_available Filter by credentials availability (optional)
     * @param  string|null $x_forwarded_for (optional)
     * @param  string|null $x_account_id (optional)
     * @param  string|null $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSuppliersExtraV1SuppliersGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSuppliersExtraV1SuppliersGetAsyncWithHttpInfo($shopify_ready = null, $credentials_available = null, $x_forwarded_for = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getSuppliersExtraV1SuppliersGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SuppliersResponse';
        $request = $this->getSuppliersExtraV1SuppliersGetRequest($shopify_ready, $credentials_available, $x_forwarded_for, $x_account_id, $body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSuppliersExtraV1SuppliersGet'
     *
     * @param  bool|null $shopify_ready Filter by Shopify readiness (optional)
     * @param  bool|null $credentials_available Filter by credentials availability (optional)
     * @param  string|null $x_forwarded_for (optional)
     * @param  string|null $x_account_id (optional)
     * @param  string|null $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSuppliersExtraV1SuppliersGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getSuppliersExtraV1SuppliersGetRequest($shopify_ready = null, $credentials_available = null, $x_forwarded_for = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getSuppliersExtraV1SuppliersGet'][0])
    {







        $resourcePath = '/extra/v1/suppliers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $shopify_ready,
            'shopify_ready', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $credentials_available,
            'credentials_available', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($x_forwarded_for !== null) {
            $headerParams['X-Forwarded-For'] = ObjectSerializer::toHeaderValue($x_forwarded_for);
        }
        // header params
        if ($x_account_id !== null) {
            $headerParams['x-account-id'] = ObjectSerializer::toHeaderValue($x_account_id);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSuppliersV2
     *
     * Get Suppliers
     *
     * @param  int|null $page page (optional, default to 1)
     * @param  int|null $page_size page_size (optional, default to 600)
     * @param  bool|null $shopify_ready shopify_ready (optional)
     * @param  bool|null $credentials_available credentials_available (optional)
     * @param  bool|null $decorations_available decorations_available (optional)
     * @param  string|null $x_forwarded_for x_forwarded_for (optional)
     * @param  string|null $x_account_id x_account_id (optional)
     * @param  string|null $body body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSuppliersV2'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SuppliersResponseV2|\OpenAPI\Client\Model\HTTPValidationError
     */
    public function getSuppliersV2($page = 1, $page_size = 600, $shopify_ready = null, $credentials_available = null, $decorations_available = null, $x_forwarded_for = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getSuppliersV2'][0])
    {
        list($response) = $this->getSuppliersV2WithHttpInfo($page, $page_size, $shopify_ready, $credentials_available, $decorations_available, $x_forwarded_for, $x_account_id, $body, $contentType);
        return $response;
    }

    /**
     * Operation getSuppliersV2WithHttpInfo
     *
     * Get Suppliers
     *
     * @param  int|null $page (optional, default to 1)
     * @param  int|null $page_size (optional, default to 600)
     * @param  bool|null $shopify_ready (optional)
     * @param  bool|null $credentials_available (optional)
     * @param  bool|null $decorations_available (optional)
     * @param  string|null $x_forwarded_for (optional)
     * @param  string|null $x_account_id (optional)
     * @param  string|null $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSuppliersV2'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SuppliersResponseV2|\OpenAPI\Client\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function getSuppliersV2WithHttpInfo($page = 1, $page_size = 600, $shopify_ready = null, $credentials_available = null, $decorations_available = null, $x_forwarded_for = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getSuppliersV2'][0])
    {
        $request = $this->getSuppliersV2Request($page, $page_size, $shopify_ready, $credentials_available, $decorations_available, $x_forwarded_for, $x_account_id, $body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\SuppliersResponseV2',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\HTTPValidationError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\SuppliersResponseV2',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SuppliersResponseV2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getSuppliersV2Async
     *
     * Get Suppliers
     *
     * @param  int|null $page (optional, default to 1)
     * @param  int|null $page_size (optional, default to 600)
     * @param  bool|null $shopify_ready (optional)
     * @param  bool|null $credentials_available (optional)
     * @param  bool|null $decorations_available (optional)
     * @param  string|null $x_forwarded_for (optional)
     * @param  string|null $x_account_id (optional)
     * @param  string|null $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSuppliersV2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSuppliersV2Async($page = 1, $page_size = 600, $shopify_ready = null, $credentials_available = null, $decorations_available = null, $x_forwarded_for = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getSuppliersV2'][0])
    {
        return $this->getSuppliersV2AsyncWithHttpInfo($page, $page_size, $shopify_ready, $credentials_available, $decorations_available, $x_forwarded_for, $x_account_id, $body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSuppliersV2AsyncWithHttpInfo
     *
     * Get Suppliers
     *
     * @param  int|null $page (optional, default to 1)
     * @param  int|null $page_size (optional, default to 600)
     * @param  bool|null $shopify_ready (optional)
     * @param  bool|null $credentials_available (optional)
     * @param  bool|null $decorations_available (optional)
     * @param  string|null $x_forwarded_for (optional)
     * @param  string|null $x_account_id (optional)
     * @param  string|null $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSuppliersV2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSuppliersV2AsyncWithHttpInfo($page = 1, $page_size = 600, $shopify_ready = null, $credentials_available = null, $decorations_available = null, $x_forwarded_for = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getSuppliersV2'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SuppliersResponseV2';
        $request = $this->getSuppliersV2Request($page, $page_size, $shopify_ready, $credentials_available, $decorations_available, $x_forwarded_for, $x_account_id, $body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSuppliersV2'
     *
     * @param  int|null $page (optional, default to 1)
     * @param  int|null $page_size (optional, default to 600)
     * @param  bool|null $shopify_ready (optional)
     * @param  bool|null $credentials_available (optional)
     * @param  bool|null $decorations_available (optional)
     * @param  string|null $x_forwarded_for (optional)
     * @param  string|null $x_account_id (optional)
     * @param  string|null $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSuppliersV2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getSuppliersV2Request($page = 1, $page_size = 600, $shopify_ready = null, $credentials_available = null, $decorations_available = null, $x_forwarded_for = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['getSuppliersV2'][0])
    {

        if ($page !== null && $page < 1) {
            throw new \InvalidArgumentException('invalid value for "$page" when calling ExtraApi.getSuppliersV2, must be bigger than or equal to 1.');
        }
        
        if ($page_size !== null && $page_size > 600) {
            throw new \InvalidArgumentException('invalid value for "$page_size" when calling ExtraApi.getSuppliersV2, must be smaller than or equal to 600.');
        }
        if ($page_size !== null && $page_size < 10) {
            throw new \InvalidArgumentException('invalid value for "$page_size" when calling ExtraApi.getSuppliersV2, must be bigger than or equal to 10.');
        }
        







        $resourcePath = '/extra/v2/suppliers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page_size,
            'page_size', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $shopify_ready,
            'shopify_ready', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $credentials_available,
            'credentials_available', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $decorations_available,
            'decorations_available', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($x_forwarded_for !== null) {
            $headerParams['X-Forwarded-For'] = ObjectSerializer::toHeaderValue($x_forwarded_for);
        }
        // header params
        if ($x_account_id !== null) {
            $headerParams['x-account-id'] = ObjectSerializer::toHeaderValue($x_account_id);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation scrapeExtraV1ScrapeSupplierCodeGet
     *
     * Scrape
     *
     * @param  \OpenAPI\Client\Model\ScraperSupplierCodes $supplier_code supplier_code (required)
     * @param  string $url url (required)
     * @param  string|null $x_forwarded_for x_forwarded_for (optional)
     * @param  string|null $x_account_id x_account_id (optional)
     * @param  string|null $body body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['scrapeExtraV1ScrapeSupplierCodeGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ScraperResponse|\OpenAPI\Client\Model\HTTPValidationError
     */
    public function scrapeExtraV1ScrapeSupplierCodeGet($supplier_code, $url, $x_forwarded_for = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['scrapeExtraV1ScrapeSupplierCodeGet'][0])
    {
        list($response) = $this->scrapeExtraV1ScrapeSupplierCodeGetWithHttpInfo($supplier_code, $url, $x_forwarded_for, $x_account_id, $body, $contentType);
        return $response;
    }

    /**
     * Operation scrapeExtraV1ScrapeSupplierCodeGetWithHttpInfo
     *
     * Scrape
     *
     * @param  \OpenAPI\Client\Model\ScraperSupplierCodes $supplier_code (required)
     * @param  string $url (required)
     * @param  string|null $x_forwarded_for (optional)
     * @param  string|null $x_account_id (optional)
     * @param  string|null $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['scrapeExtraV1ScrapeSupplierCodeGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ScraperResponse|\OpenAPI\Client\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function scrapeExtraV1ScrapeSupplierCodeGetWithHttpInfo($supplier_code, $url, $x_forwarded_for = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['scrapeExtraV1ScrapeSupplierCodeGet'][0])
    {
        $request = $this->scrapeExtraV1ScrapeSupplierCodeGetRequest($supplier_code, $url, $x_forwarded_for, $x_account_id, $body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ScraperResponse',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\HTTPValidationError',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\ScraperResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ScraperResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation scrapeExtraV1ScrapeSupplierCodeGetAsync
     *
     * Scrape
     *
     * @param  \OpenAPI\Client\Model\ScraperSupplierCodes $supplier_code (required)
     * @param  string $url (required)
     * @param  string|null $x_forwarded_for (optional)
     * @param  string|null $x_account_id (optional)
     * @param  string|null $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['scrapeExtraV1ScrapeSupplierCodeGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function scrapeExtraV1ScrapeSupplierCodeGetAsync($supplier_code, $url, $x_forwarded_for = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['scrapeExtraV1ScrapeSupplierCodeGet'][0])
    {
        return $this->scrapeExtraV1ScrapeSupplierCodeGetAsyncWithHttpInfo($supplier_code, $url, $x_forwarded_for, $x_account_id, $body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation scrapeExtraV1ScrapeSupplierCodeGetAsyncWithHttpInfo
     *
     * Scrape
     *
     * @param  \OpenAPI\Client\Model\ScraperSupplierCodes $supplier_code (required)
     * @param  string $url (required)
     * @param  string|null $x_forwarded_for (optional)
     * @param  string|null $x_account_id (optional)
     * @param  string|null $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['scrapeExtraV1ScrapeSupplierCodeGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function scrapeExtraV1ScrapeSupplierCodeGetAsyncWithHttpInfo($supplier_code, $url, $x_forwarded_for = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['scrapeExtraV1ScrapeSupplierCodeGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ScraperResponse';
        $request = $this->scrapeExtraV1ScrapeSupplierCodeGetRequest($supplier_code, $url, $x_forwarded_for, $x_account_id, $body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'scrapeExtraV1ScrapeSupplierCodeGet'
     *
     * @param  \OpenAPI\Client\Model\ScraperSupplierCodes $supplier_code (required)
     * @param  string $url (required)
     * @param  string|null $x_forwarded_for (optional)
     * @param  string|null $x_account_id (optional)
     * @param  string|null $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['scrapeExtraV1ScrapeSupplierCodeGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function scrapeExtraV1ScrapeSupplierCodeGetRequest($supplier_code, $url, $x_forwarded_for = null, $x_account_id = null, $body = null, string $contentType = self::contentTypes['scrapeExtraV1ScrapeSupplierCodeGet'][0])
    {

        // verify the required parameter 'supplier_code' is set
        if ($supplier_code === null || (is_array($supplier_code) && count($supplier_code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $supplier_code when calling scrapeExtraV1ScrapeSupplierCodeGet'
            );
        }

        // verify the required parameter 'url' is set
        if ($url === null || (is_array($url) && count($url) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $url when calling scrapeExtraV1ScrapeSupplierCodeGet'
            );
        }
        if (strlen($url) > 2083) {
            throw new \InvalidArgumentException('invalid length for "$url" when calling ExtraApi.scrapeExtraV1ScrapeSupplierCodeGet, must be smaller than or equal to 2083.');
        }
        if (strlen($url) < 1) {
            throw new \InvalidArgumentException('invalid length for "$url" when calling ExtraApi.scrapeExtraV1ScrapeSupplierCodeGet, must be bigger than or equal to 1.');
        }
        




        $resourcePath = '/extra/v1/scrape/{supplier_code}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $url,
            'url', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);

        // header params
        if ($x_forwarded_for !== null) {
            $headerParams['X-Forwarded-For'] = ObjectSerializer::toHeaderValue($x_forwarded_for);
        }
        // header params
        if ($x_account_id !== null) {
            $headerParams['x-account-id'] = ObjectSerializer::toHeaderValue($x_account_id);
        }

        // path params
        if ($supplier_code !== null) {
            $resourcePath = str_replace(
                '{' . 'supplier_code' . '}',
                ObjectSerializer::toPathValue($supplier_code),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        if ($this->config->getCertFile()) {
            $options[RequestOptions::CERT] = $this->config->getCertFile();
        }

        if ($this->config->getKeyFile()) {
            $options[RequestOptions::SSL_KEY] = $this->config->getKeyFile();
        }

        return $options;
    }

    private function handleResponseWithDataType(
        string $dataType,
        RequestInterface $request,
        ResponseInterface $response
    ): array {
        if ($dataType === '\SplFileObject') {
            $content = $response->getBody(); //stream goes to serializer
        } else {
            $content = (string) $response->getBody();
            if ($dataType !== 'string') {
                try {
                    $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                } catch (\JsonException $exception) {
                    throw new ApiException(
                        sprintf(
                            'Error JSON decoding server response (%s)',
                            $request->getUri()
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                        $content
                    );
                }
            }
        }

        return [
            ObjectSerializer::deserialize($content, $dataType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    private function responseWithinRangeCode(
        string $rangeCode,
        int $statusCode
    ): bool {
        $left = (int) ($rangeCode[0].'00');
        $right = (int) ($rangeCode[0].'99');

        return $statusCode >= $left && $statusCode <= $right;
    }
}
